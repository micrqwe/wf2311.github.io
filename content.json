{"meta":{"title":"王峰的个人博客","subtitle":null,"description":null,"author":"王峰","url":"https://www.wf2311.com"},"pages":[{"title":"","date":"2018-01-12T12:02:36.994Z","updated":"2018-01-12T12:02:36.993Z","comments":false,"path":"categories/index.html","permalink":"https://www.wf2311.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-12T12:02:06.989Z","updated":"2018-01-12T12:02:06.988Z","comments":false,"path":"tags/index.html","permalink":"https://www.wf2311.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring事件的使用","slug":"Spring事件的使用","date":"2018-01-15T13:57:13.000Z","updated":"2018-01-15T13:57:36.455Z","comments":true,"path":"Spring事件的使用.html","link":"","permalink":"https://www.wf2311.com/Spring事件的使用.html","excerpt":"","text":"简介 Spring 的事件(Spring Application Event)为 Bean 与 Bean 之间传递消息。一个 Bean 处理完了希望其余一个接着处理。这时我们就需要其余的一个 Bean 监听当前 Bean 所发送的事件。 Spring 事件使用步骤如下: 先自定义事件: 需要继承ApplicationEvent ; 定义事件监听者: 使用注解@EventListener或者实现ApplicationListener; 使用容器对事件进行发布;基于注解监听模式的基本用法以下用一个每天的定时同步任务为例进行讲解:定义同步事件SyncEvent:123456789/** * 同步任务事件 * @author wf2311 */public class SyncEvent extends ApplicationEvent&#123; public SyncEvent(Object source) &#123; super(source); &#125;&#125; 事件监听者定义一个 MailHandler.java 在监听到事件后发送邮件:12345678910111213141516/** * 邮件发送处理器 * * @author wf2311 */@Servicepublic class MailHandler &#123; private static final Logger log = LoggerFactory.getLogger(MailService.class); @EventListener public void sendSycResult(SyncEvent event) throws InterruptedException &#123; log.debug(\"MailHandler接收到同步结果:&#123;&#125;\",event); TimeUnit.SECONDS.sleep(1); log.debug(\"mock send sync data ...\"); &#125;&#125; 在void sendSycResult(SyncEvent event)方法上使用注解@EventListener, 表明sendSycResult方法将会监听SyncEvent事件; EventListener的源码如下:1234567891011121314151617181920212223242526@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface EventListener &#123; /** * classes的别名 */ @AliasFor(\"classes\") Class&lt;?&gt;[] value() default &#123;&#125;; /** * 要监听的事件类。 * 如果该属性只绑定了一个监听类，那使用该注解的方法最多只能有一个参数，并且参数类型需要该属性绑定的监听类相匹配(即参数类型需是监听类或者其父类); * 如果该属性绑定了多个监听类，那使用该注解的方法不能带有任何参数。 */ @AliasFor(\"value\") Class&lt;?&gt;[] classes() default &#123;&#125;; /** * 匹配条件，SpEL表达式； * 默认为空，表示总是匹配 */ String condition() default \"\";&#125; 发布事件SyncService:123456789101112131415161718192021222324252627/** * 数据同步服务 * * @author wf2311 */@Servicepublic class SyncService &#123; private static final Logger log = LoggerFactory.getLogger(SyncService.class); @Autowired private ApplicationEventPublisher applicationEventPublisher; public void syncDayData(LocalDate day) throws InterruptedException &#123; log.debug(\"开始同步&#123;&#125;的数据\", day); long start = System.currentTimeMillis(); TimeUnit.SECONDS.sleep(1); long end = System.currentTimeMillis(); long speed = end - start; log.debug(\"&#123;&#125;的数据同步完成,耗时&#123;&#125; ms\", day, speed); SyncData syncData = SyncData.builder().day(day).speed(speed).data(new Object()).build(); applicationEventPublisher.publishEvent(new SyncEvent(syncData, \"mail\")); TimeUnit.SECONDS.sleep(3); long end2 = System.currentTimeMillis(); log.debug(\"sleep &#123;&#125; ns\", end2 - end); &#125;&#125; 测试12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringEventApplicationTests &#123; @Autowired private SyncService syncService; @Test public void testSyncData() throws InterruptedException &#123; syncService.syncDayData(LocalDate.now()); &#125;&#125; 运行测试方法testSyncData(),得到如下结果:123452018-01-15 16:37:11.387 DEBUG 132812 --- [ main] c.w.s.e.s.SyncService : 开始同步2018-01-15的数据2018-01-15 16:37:12.389 DEBUG 132812 --- [ main] c.w.s.e.s.SyncService : 2018-01-15的数据同步完成,耗时1001 ms2018-01-15 16:37:12.390 DEBUG 132812 --- [ main] c.w.s.e.h.MailHandler : MailHandler接收到同步结果:SyncEvent(type=mail)2018-01-15 16:37:13.391 DEBUG 132812 --- [ main] c.w.s.e.h.MailHandler : mock send sync data ...2018-01-15 16:37:16.391 DEBUG 132812 --- [ main] c.w.s.e.s.SyncService : sleep 4002 ns 由测试结果可知：在方法syncDayData()运行到applicationEventPublisher.publishEvent(new SyncEvent(syncData))后就会立即自动调用void sendSycResult(SyncEvent event)方法。 多个事件监听者如果在同步任务完成后，不仅需要发送邮件，还需要对数据进行缓存和消息推送，只需要仿照MailHandler,再建立相应的类。CacheHandler:1234567891011121314151617/** * 缓存处理器 * @author wf2311 */@Componentpublic class CacheHandler &#123; private static final Logger log = LoggerFactory.getLogger(CacheHandler.class); @EventListener public void cacheSycResult(SyncEvent event) throws InterruptedException &#123; log.debug(\"CacheHandler接收到同步结果:&#123;&#125;\", event.getSource()); TimeUnit.SECONDS.sleep(2); log.debug(\"mock cache sync data ...\"); &#125;&#125; MqHandler:1234567891011@Componentpublic class MqHandler &#123; private static final Logger log = LoggerFactory.getLogger(MqHandler.class); @EventListener public void pushSycResult(SyncEvent event) throws InterruptedException &#123; log.debug(\"MqHandler接收到同步结果:&#123;&#125;\", event.getSource()); TimeUnit.SECONDS.sleep(3); log.debug(\"mock push sync data ...\"); &#125;&#125; 运行syncDayData()测试方法得到如下结果:1234567892018-01-15 16:44:57.280 DEBUG 135208 --- [ main] c.w.s.e.s.SyncService : 开始同步2018-01-15的数据2018-01-15 16:44:58.281 DEBUG 135208 --- [ main] c.w.s.e.s.SyncService : 2018-01-15的数据同步完成,耗时1001 ms2018-01-15 16:44:58.282 DEBUG 135208 --- [ main] c.w.s.e.h.CacheHandler : CacheHandler接收到同步结果:SyncData(day=2018-01-15, speed=1001, data=java.lang.Object@3f9270ed)2018-01-15 16:45:00.282 DEBUG 135208 --- [ main] c.w.s.e.h.CacheHandler : mock cache sync data ...2018-01-15 16:45:00.282 DEBUG 135208 --- [ main] c.w.s.e.h.MailHandler : MailHandler接收到同步结果:SyncEvent(type=mail)2018-01-15 16:45:01.283 DEBUG 135208 --- [ main] c.w.s.e.h.MailHandler : mock send sync data ...2018-01-15 16:45:01.283 DEBUG 135208 --- [ main] c.w.s.e.h.MqHandler : MqHandler接收到同步结果:SyncData(day=2018-01-15, speed=1001, data=java.lang.Object@3f9270ed)2018-01-15 16:45:04.283 DEBUG 135208 --- [ main] c.w.s.e.h.MqHandler : mock push sync data ...2018-01-15 16:45:07.283 DEBUG 135208 --- [ main] c.w.s.e.s.SyncService : sleep 9002 ns 由测试结果可以看出，在方法syncDayData()运行到applicationEventPublisher.publishEvent(new SyncEvent(syncData))后就会立即依次调用我们定义的多个监听者。但是如果我们对邮件发送、消息推送、缓存更新的执行顺序由特定的需求怎么办？(经简单测试，在有多个监听者时，默认情况下监听者的执行顺序是安装监听者所在的类名(不是beanName)来执行的) 使用@Order来指定监听者执行顺序查看EventListener的API文档，其中有这样一段描述： It is also possible to define the order in which listeners for a certain event are to be invoked. To do so, add Spring’s common @Order annotation alongside this event listener annotation. 所以我们可以用@Order来配合@EventListener来指定多个监听者的执行顺序。分别修改MailHandler:12345@EventListener@Order(1)public void sendSycResult(SyncEvent event) throws InterruptedException &#123; //...&#125; CacheHandler:12345@EventListener@Order(2)public void cacheSycResult(SyncEvent event) throws InterruptedException &#123; //...&#125; MqHandler:12345@EventListener@Order(3)public void pushSycResult(SyncEvent event) throws InterruptedException &#123; //...&#125; 以上的代码为我们指定了3个监听者的依次执行顺序为: MailHandler、CacheHandler、MqHandler再次运行syncDayData()测试方法得到如下结果:1234567892018-01-15 17:09:34.830 DEBUG 138192 --- [ main] c.w.s.e.s.SyncService : 开始同步2018-01-15的数据2018-01-15 17:09:35.831 DEBUG 138192 --- [ main] c.w.s.e.s.SyncService : 2018-01-15的数据同步完成,耗时1001 ms2018-01-15 17:09:35.832 DEBUG 138192 --- [ main] c.w.s.e.h.MailHandler : MailHandler接收到同步结果:SyncEvent(type=mail)2018-01-15 17:09:36.832 DEBUG 138192 --- [ main] c.w.s.e.h.MailHandler : mock send sync data ...2018-01-15 17:09:36.832 DEBUG 138192 --- [ main] c.w.s.e.h.CacheHandler : CacheHandler接收到同步结果:SyncData(day=2018-01-15, speed=1001, data=java.lang.Object@129bd55d)2018-01-15 17:09:38.833 DEBUG 138192 --- [ main] c.w.s.e.h.CacheHandler : mock cache sync data ...2018-01-15 17:09:38.833 DEBUG 138192 --- [ main] c.w.s.e.h.MqHandler : MqHandler接收到同步结果:SyncData(day=2018-01-15, speed=1001, data=java.lang.Object@129bd55d)2018-01-15 17:09:41.833 DEBUG 138192 --- [ main] c.w.s.e.h.MqHandler : mock push sync data ...2018-01-15 17:09:44.834 DEBUG 138192 --- [ main] c.w.s.e.s.SyncService : sleep 9003 ns 测试顺序与设置的顺序一致。 基于多个监听者的链式调用同样是在EventListener的API文档中，有这样一段描述： Annotated methods may have a non-void return type. When they do, the result of the method invocation is sent as a new event. If the return type is either an array or a collection, each element is sent as a new individual event. 大概意思是说: EventListener注解的方法，可以返回一个非空的类型。并且该方法的返回结果可以作为一个新的事件被发送。如果返回类型是数组或集合，则将每个元素作为新的单独事件发送。我们可以基于此特性，实现多个监听者的链式调用。 定义 OrderInfo: 123456789101112/** * @author wf2311 */@Data@Builderpublic class OrderInfo&#123; private String customer; private LocalDateTime orderTime; private Integer emailResultId; private Integer cacheResultId; private Integer mqResultId;&#125; 订单事件类 OrderEvent 12345678910111213/** * 订单事件 * @author wf2311 */@Datapublic class OrderEvent extends ApplicationEvent &#123; private String nextListenerType; public OrderEvent(Object source, String nextListenerType) &#123; super(source); this.nextListenerType = nextListenerType; &#125;&#125; 设置订单事件监听者MqHandler中,添加: 12345678@EventListener(condition = \"#event.nextListenerType == 'mq'\")public OrderEvent pushOrderInfo(OrderEvent event) &#123; log.debug(\"MqHandler接收到订单信息:&#123;&#125;\", event); ((OrderInfo) event.getSource()).setMqResultId(1); log.debug(\"mock push order event ...\"); event.setNextListenerType(\"cache\"); return event;&#125; CacheHandler中,添加:12345678@EventListener(condition = \"event.nextListenerType == 'cache'\")public OrderEvent cacheOrderInfo(OrderEvent event) &#123; log.debug(\"CacheHandler接收到订单信息:&#123;&#125;\", event.getSource()); ((OrderInfo) event.getSource()).setCacheResultId(2); log.debug(\"mock cache order info ...\"); event.setNextListenerType(\"mail\"); return event;&#125; 在MailHandler中,添加:12345678@EventListener(condition = \"#event.nextListenerType == 'mail'\")public OrderEvent sendOrderInfo(OrderEvent event) &#123; log.debug(\"MailHandler接收到订单信息:&#123;&#125;\", event.getSource()); ((OrderInfo) event.getSource()).setMqResultId(3); log.debug(\"mock send order event ...\"); event.setNextListenerType(null); return event;&#125; 以上各个EventListener中的condition表示，只有当对应的事件中对应的自定义属性nextListenerType等于对应值时，才会执行该方法。 设置事件发布者:OrderService: 12345678910111213141516171819/** * 订单服务 * @author wf2311 */@Servicepublic class OrderService &#123; private static final Logger log = LoggerFactory.getLogger(OrderService.class); @Autowired private ApplicationEventPublisher applicationEventPublisher; public void saveOrder(String customer, LocalDateTime time) throws InterruptedException &#123; OrderInfo order = OrderInfo.builder().orderTime(time).customer(customer).build(); log.debug(\"保存订单信息:&#123;&#125;\", order); TimeUnit.SECONDS.sleep(3); applicationEventPublisher.publishEvent(new OrderEvent(order, \"mq\")); &#125;&#125; 测试方法： 123456@Autowiredprivate OrderService orderService;@Testpublic void testOrderInfo() throws InterruptedException &#123; orderService.saveOrder(\"test\", LocalDateTime.now());&#125; 运行后得到如下结果：12345672018-01-15 18:51:46.677 DEBUG 135904 --- [ main] c.w.s.e.s.OrderService : 保存订单信息:OrderInfo(customer=test, orderTime=2018-01-15T18:51:46.674, emailResultId=null, cacheResultId=null, mqResultId=null)2018-01-15 18:51:49.702 DEBUG 135904 --- [ main] c.w.s.e.h.MqHandler : MqHandler接收到订单信息:OrderEvent(nextListenerType=mq)2018-01-15 18:51:49.702 DEBUG 135904 --- [ main] c.w.s.e.h.MqHandler : mock push order event ...2018-01-15 18:51:49.703 DEBUG 135904 --- [ main] c.w.s.e.h.CacheHandler : CacheHandler接收到订单信息:OrderInfo(customer=test, orderTime=2018-01-15T18:51:46.674, emailResultId=null, cacheResultId=null, mqResultId=1)2018-01-15 18:51:49.703 DEBUG 135904 --- [ main] c.w.s.e.h.CacheHandler : mock cache order info ...2018-01-15 18:51:49.703 DEBUG 135904 --- [ main] c.w.s.e.h.MailHandler : MailHandler接收到订单信息:OrderInfo(customer=test, orderTime=2018-01-15T18:51:46.674, emailResultId=null, cacheResultId=2, mqResultId=1)2018-01-15 18:51:49.703 DEBUG 135904 --- [ main] c.w.s.e.h.MailHandler : mock send order event ... 结果分析：saveOrder()发布的事件中event.nextListenerType = ‘mq’,只有pushOrderInfo()方法符合条件；执行完pushOrderInfo()后，event.nextListenerType变为’cache’,只有cacheOrderInfo()方法符合条件；执行完cacheOrderInfo()后,event.nextListenerType变为’mail’,只有sendOrderInfo()方法符合条件；执行完sendOrderInfo()后,event.nextListenerType变为null,无符合条件的事件监听者，结束事件监听； 基于实现ApplicationListener的事件监听者参考Spring Application Event Example","categories":[{"name":"Spring","slug":"Spring","permalink":"https://www.wf2311.com/categories/Spring/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.wf2311.com/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","permalink":"https://www.wf2311.com/tags/Spring/"},{"name":"ApplicationEvent","slug":"ApplicationEvent","permalink":"https://www.wf2311.com/tags/ApplicationEvent/"}]},{"title":"有了Closeable为什么还要定义AutoCloseable","slug":"有了Closeable为什么还要定义AutoCloseable","date":"2017-09-27T01:24:31.000Z","updated":"2018-01-15T13:57:36.455Z","comments":true,"path":"有了Closeable为什么还要定义AutoCloseable.html","link":"","permalink":"https://www.wf2311.com/有了Closeable为什么还要定义AutoCloseable.html","excerpt":"","text":"从try-with-resources语法块说起我们知道java7中引入了新的语法块try-with-resources:实现了java.lang.AutoCloseable的对象都可以作为资源，在try后面的括号类声明实例化，在后面的{...}语句块执行完后被自动关闭(close()方法被自动调用)。例如：在java7前，我们需要这样定义语句:1234567891011121314public void writeFile(String path,byte[] data)&#123; OutputStream os = null; try &#123; os = new FileOutputStream(path); os.write(data); os.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (os!=null)&#123; os.close(); &#125; &#125;&#125; 而在java7后，可以变成这样：12345678public void writeFile(String path,byte[] data)&#123; try ( OutputStream os = new FileOutputStream(path))&#123; os.write(data); os.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Closeable与AutoCloseable的关系与区别AutoCloseable的源码如下:123456/** * @since 1.7 */public interface AutoCloseable &#123; void close() throws Exception;&#125; Closeable的源码如下:123456/** * @since 1.5 */public interface Closeable extends AutoCloseable &#123; public void close() throws IOException;&#125; 由上可知Closeable在jdk1.5中就定义了，而AutoCloseable在jdk1.7才被引入，并且Closeable继承了AutoCloseable。为什么要这样设计呢？答案很简单，仔细查看源码就可以知道原因:因为Closeable的close()方法只会抛出IOException异常，而AutoCloseable的close()方法抛出的是Exception异常。如此一来try-with-resources的适用性就更大了。 参考 https://stackoverflow.com/questions/19572537/why-is-autocloseable-the-base-interface-for-closeable-and-not-vice-versa","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wf2311.com/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://www.wf2311.com/tags/java基础/"},{"name":"io","slug":"io","permalink":"https://www.wf2311.com/tags/io/"}]},{"title":"IDEA 远程调试spring boot项目","slug":"IDEA 远程调试spring boot项目","date":"2017-09-21T01:33:52.000Z","updated":"2018-01-15T13:57:36.455Z","comments":true,"path":"IDEA 远程调试spring boot项目.html","link":"","permalink":"https://www.wf2311.com/IDEA 远程调试spring boot项目.html","excerpt":"","text":"IDEA 远程调试spring boot项目1. Dokcer容器中在Dockefile中配置(方法1)在Dockerfile文件中加入参数-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n,例如：123...ENV JAVA_OPTS=\"-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n\"ENTRYPOINT [ \"sh\", \"-c\", \"java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar\" ] 启动docker命令：1docker run -p 8000:8000 -p 4000:4000 -t imageName 参数说明： -p 8000:8000 表示把在Dockerfile中定义的远程调试端口8000映射到服务器端口8000中； -p 4000:4000 表示把在应用程序的启动端口4000映射到服务器端口4000中；启动命令中配置(方法2)在启动命令中加上参数-e &quot;JAVA_OPTS=-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=y&quot;，例如：1docker run -e \"JAVA_OPTS=-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=y\" -p 8000:8000 -p 4000:4000 -t imageName 2. 以嵌入式web容器运行时在启动命令中加上参数-e &quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000，例如：1java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000 -jar application.jar 3. 以mvn spring-boot:run运行时在pom.xml中加入如下插件:123456789&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;jvmArguments&gt; -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 &lt;/jvmArguments&gt; &lt;/configuration&gt;&lt;/plugin&gt; 参考资料 debug spring-boot in docker spring boot + IDEA 远程调试 Spring Boot Maven Plugin - Debug the application","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.wf2311.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.wf2311.com/tags/SpringBoot/"},{"name":"远程调试","slug":"远程调试","permalink":"https://www.wf2311.com/tags/远程调试/"}]},{"title":"spring boot + IDEA 远程调试","slug":"spring boot + IDEA 远程调试","date":"2017-09-19T02:20:54.000Z","updated":"2018-01-15T13:57:36.454Z","comments":true,"path":"spring boot + IDEA 远程调试.html","link":"","permalink":"https://www.wf2311.com/spring boot + IDEA 远程调试.html","excerpt":"","text":"配置若想调试远端web容器内部的应用，需要接入web容器的jvm，以Tomcat为例，需修改web容器的配置1234567// bin\\startup.bat（.sh）文件，在里面添加 // windowsset CATALINA_OPTS=\"-agentlib:jdwp=transport=dt_socket,address=8888（自定义调试端口）,server=y,suspend=n %CATALINA_OPTS%\" // linuxexport CATALINA_OPTS=\"-agentlib:jdwp=transport=dt_socket,address= 8888（自定义调试端口）,server=y,suspend=n $CATALINA_OPTS\" 若是使用了spring boot并将工程打成了可执行JAR包12345// 在使用java指令启动程序时需要附加额外的参数以开启外部调试，如下-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8888（自定义调试端口） // 完整的启动指令是类似下面酱的java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8888（自定义调试端口） -jar application.jar IDEA连接远端调试 填写远端JMV所在服务器IP和调试端口号，保存即可： 连接远端JVM启动调试： 如若连接成功，调试控制台将输出以下内容，如果没成功，请自行检查服务器防火墙以及网络 接下来的操作就和在本地调试一样了，打断点，远端JVM会通过网络同步调试信息，和在本地没什么两样，要注意调试的时候和本地一样都是会暂停JVM继续往下执行的。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.wf2311.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.wf2311.com/tags/SpringBoot/"},{"name":"远程调试","slug":"远程调试","permalink":"https://www.wf2311.com/tags/远程调试/"}]},{"title":"JetBrains插件推荐","slug":"JetBrains插件推荐","date":"2017-09-13T01:09:17.000Z","updated":"2018-01-15T13:57:36.454Z","comments":true,"path":"JetBrains插件推荐.html","link":"","permalink":"https://www.wf2311.com/JetBrains插件推荐.html","excerpt":"","text":"翻译插件TranslationPluginJetBrains IDE/Android Studio 翻译插件，支持中英互译、单词朗读。[项目主页] https://github.com/YiiGuxing/TranslationPlugin[插件下载地址] https://plugins.jetbrains.com/idea/plugin/8579","categories":[{"name":"其它","slug":"其它","permalink":"https://www.wf2311.com/categories/其它/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://www.wf2311.com/tags/插件/"},{"name":"app","slug":"app","permalink":"https://www.wf2311.com/tags/app/"}]},{"title":"Java的枚举类使用技巧","slug":"Java的枚举类使用技巧","date":"2017-08-02T06:05:07.000Z","updated":"2018-01-15T13:57:36.454Z","comments":true,"path":"Java的枚举类使用技巧.html","link":"","permalink":"https://www.wf2311.com/Java的枚举类使用技巧.html","excerpt":"","text":"枚举接口在web开发中我们常常会定义一些enum来表示常量，比如:1234567891011121314151617181920212223enum BlogType &#123; BLOG(1, \"原创博文\"), REPRINT(2, \"转载文章\"), QUESTION(3, \"问答\"), VOTE(4, \"投票\"), SUBJECT(5, \"专栏\"); private Integer code; private String name; BlogType(Integer code, String name) &#123; this.code = code; this.name = name; &#125; public Integer getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125;&#125; 以及:123456789101112131415161718192021enum BlogStatus &#123; PRIVATE(1, \"自己可见\"), FRIEND(2, \"好友可见\"), ONLINE(3, \"登陆用户可见\"), PUBLISH(4, \"公开\"); private Integer code; private String name; BlogStatus(Integer code, String name) &#123; this.code = code; this.name = name; &#125; public Integer getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125;&#125; 可以看出它们的结构一样，都有code和name这两个属性，以及对应的getter方法，因此可以定义一个如下的接口：123456public interface Common&lt;C, N&gt; &#123; C getCode(); N getName();&#125; 所有如上面的常量枚举类都可以实现该接口。1234567enum BlogType implements Common &#123; //...&#125;enum BlogStatus implements Common &#123; //...&#125; 公用静态方法我们可以在在Common接口中定义一个如下的静态方法：12345static &lt;E extends Enum&lt;E&gt; &amp; Common, C&gt; E getByCode(Class&lt;E&gt; clazz, C code) &#123; return Arrays.stream(clazz.getEnumConstants()) .filter(t -&gt; t.getCode().equals(code)) .findFirst().orElse(null);&#125; 使用此方法可以根据code来查找指定的Common实现类中的值，比如：12Assert.assertEquals(BlogType.QUESTION, Common.getByCode(BlogType.class, BlogType.QUESTION.getCode()));Assert.assertEquals(BlogStatus.PUBLISH, Common.getByCode(BlogType.class, BlogStatus.PUBLISH.getCode())); 自定义序列化当我们定义如下的方法123456789@GetMapping(\"/consts\")public ApiResult consts() &#123; ApiResult result = new ApiResult(); Map&lt;String, Object&gt; consts = new HashMap&lt;&gt;(); consts.put(\"blogType\", BlogType.values()); consts.put(\"blogStatus\", BlogStatus.values()); result.setData(consts); return result;&#125; 通过请求，得到的结果格式是12345678910111213141516171819&#123; \"code\": 0, \"success\": true, \"data\": &#123; \"blogStatus\": [ \"PRIVATE\", \"FRIEND\", \"ONLINE\", \"PUBLISH\" ], \"blogType\": [ \"BLOG\", \"REPRINT\", \"QUESTION\", \"VOTE\", \"SUBJECT\" ] &#125;&#125; 而我们期待的到是格式是包含code和name的键值对的形式，而不是以上的形式。通过在Common接口中添加以上方法可以实现：123456@JsonValuedefault Map&lt;C, N&gt; toMap() &#123; Map&lt;C, N&gt; map = new HashMap&lt;&gt;(1); map.put(getCode(), getName()); return map;&#125; 此时再次通过页面请求，得到的结果将如下：12345678910111213141516171819202122232425262728293031323334353637&#123; \"code\": 0, \"success\": true, \"data\": &#123; \"blogStatus\": [ &#123; \"1\": \"自己可见\" &#125;, &#123; \"2\": \"好友可见\" &#125;, &#123; \"3\": \"登陆用户可见\" &#125;, &#123; \"4\": \"公开\" &#125; ], \"blogType\": [ &#123; \"1\": \"原创博文\" &#125;, &#123; \"2\": \"转载文章\" &#125;, &#123; \"3\": \"问答\" &#125;, &#123; \"4\": \"投票\" &#125;, &#123; \"5\": \"专栏\" &#125; ] &#125;&#125; 此外，如果想通过使用fastjson的JSON.toJSONString()也能得到如上格式的结果，可以让Common继承com.alibaba.fastjson.JSONAware,并在Common中实现JSONAware的toJSONString方法:1234@Overridedefault String toJSONString() &#123; return JSON.toJSONString(toMap());&#125; 以下代码将会通过:1Assert.assertEquals(\"&#123;2:\\\"转载文章\\\"&#125;\", JSON.toJSONString(BlogType.REPRINT)); 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONAware;import com.fasterxml.jackson.annotation.JsonValue;import java.util.Arrays;import java.util.HashMap;import java.util.Map;/** * @author wf2311 */public interface Enums &#123; interface Common&lt;C, N&gt; extends JSONAware &#123; C getCode(); N getName(); static &lt;E extends Enum&lt;E&gt; &amp; Common, C&gt; E getByCode(Class&lt;E&gt; clazz, C code) &#123; return Arrays.stream(clazz.getEnumConstants()) .filter(t -&gt; t.getCode().equals(code)) .findFirst().orElse(null); &#125; @JsonValue default Map&lt;C, N&gt; toMap() &#123; Map&lt;C, N&gt; map = new HashMap&lt;&gt;(1); map.put(getCode(), getName()); return map; &#125; @Override default String toJSONString() &#123; return JSON.toJSONString(toMap()); &#125; &#125; enum BlogType implements Common &#123; BLOG(1, \"原创博文\"), REPRINT(2, \"转载文章\"), QUESTION(3, \"问答\"), VOTE(4, \"投票\"), SUBJECT(5, \"专栏\"); private Integer code; private String name; BlogType(Integer code, String name) &#123; this.code = code; this.name = name; &#125; public Integer getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125; &#125; enum BlogStatus implements Common &#123; PRIVATE(1, \"自己可见\"), FRIEND(2, \"好友可见\"), ONLINE(3, \"登陆用户可见\"), PUBLISH(4, \"公开\"); private int code; private String name; BlogStatus(Integer code, String name) &#123; this.code = code; this.name = name; &#125; public Integer getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wf2311.com/categories/Java/"}],"tags":[{"name":"enum","slug":"enum","permalink":"https://www.wf2311.com/tags/enum/"},{"name":"json","slug":"json","permalink":"https://www.wf2311.com/tags/json/"}]},{"title":"Maven常用命令","slug":"Maven常用命令","date":"2017-07-28T08:49:07.000Z","updated":"2018-01-15T13:57:36.453Z","comments":true,"path":"Maven常用命令.html","link":"","permalink":"https://www.wf2311.com/Maven常用命令.html","excerpt":"","text":"更新父模块到指定版本号 1mvn versions:set -DnewVersion=1.0.1-SNAPSHOT 更新子模块版本到与模块相同 1mvn -N versions:update-child-modules 发布版本到指定本地仓库 1mvn deploy -DskipTests -DaltDeploymentRepository=wf2311-mvn-repo::default::file:D:/Projects/open-source/maven-repo/repository/ 跳过测试 1-DskipTests 跳过gpg签名 1-DskipGPG 查看执行过程 1-X 把jar包加入本地仓库 1mvn install:install-file -Dfile=D:\\thrift-0.9.2.jar -DgroupId=org.apache.thrift -DartifactId=libthrift -Dversion=0.9.2 -Dpackaging=jar","categories":[{"name":"其它","slug":"其它","permalink":"https://www.wf2311.com/categories/其它/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://www.wf2311.com/tags/maven/"}]},{"title":"SpringBoot中使用thymeleaf模板在找不到对于模板的解决方法","slug":"SpringBoot中使用thymeleaf模板在找不到对于模板的解决方法","date":"2017-07-28T03:04:21.000Z","updated":"2018-01-15T13:57:36.453Z","comments":true,"path":"SpringBoot中使用thymeleaf模板在找不到对于模板的解决方法.html","link":"","permalink":"https://www.wf2311.com/SpringBoot中使用thymeleaf模板在找不到对于模板的解决方法.html","excerpt":"","text":"问题描述SpringBoot中使用thymeleaf模板，在IDEA中以main方法运行可以正常显示页面，但在打包之后就会提示找不到模板页面的错误信息:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[THYMELEAF][http-nio-4000-exec-1] Exception processing template \"/blog/index\": Error resolving template \"/blog/index\", template might not exist or might not be accessible by any of the configured Template Resolversorg.thymeleaf.exceptions.TemplateInputException: Error resolving template \"/blog/index\", template might not exist or might not be accessible by any of the configured Template Resolvers at org.thymeleaf.engine.TemplateManager.resolveTemplate(TemplateManager.java:870) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:607) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.renderFragment(ThymeleafView.java:353) [thymeleaf-spring4-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.render(ThymeleafView.java:191) [thymeleaf-spring4-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1286) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1041) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:984) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) [tomcat-embed-websocket-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter.doFilter(ResourceUrlEncodingFilter.java:59) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_74] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_74] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at java.lang.Thread.run(Thread.java:745) [?:1.8.0_74]Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: Error resolving template \"/blog/index\", template might not exist or might not be accessible by any of the configured Template Resolvers] with root causeorg.thymeleaf.exceptions.TemplateInputException: Error resolving template \"/blog/index\", template might not exist or might not be accessible by any of the configured Template Resolvers at org.thymeleaf.engine.TemplateManager.resolveTemplate(TemplateManager.java:870) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:607) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.renderFragment(ThymeleafView.java:353) ~[thymeleaf-spring4-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.render(ThymeleafView.java:191) ~[thymeleaf-spring4-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1286) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1041) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:984) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) ~[tomcat-embed-websocket-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter.doFilter(ResourceUrlEncodingFilter.java:59) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_74] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_74] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at java.lang.Thread.run(Thread.java:745) [?:1.8.0_74] 错误原因参考stackflow 类似的问题 You don’t need the leading / on the view name, i.e. you should return fragments :: nodeList rather than /fragments :: nodeList. Having made this change Thymeleaf should be able to find the template when run from your IDE or from a jar file.If you’re interested, here’s what’s happening under the hood:The view name is used to search for a resource on the classpath. fragments :: nodeList means that the resource name is /templates/fragments.html and /fragments :: nodeList means that the resource name is /templates//fragments.html (note the double slash). When you’re running in your IDE the resource is available straight off the filesystem and the double slash doesn’t cause a problem. When you’re running from a jar file the resource is nested within that jar and the double slash prevents it from being found. I don’t fully understand why there’s this difference in behaviour and it is rather unfortunate. I’ve opened an issue so that we (the Spring Boot team) can see if there’s anything we can do to make the behaviour consistent. 简单来说就是在springboot配置文件里的spring.thymeleaf.prefix=classpath:/templates/的与返回页面的视图设置mav.setViewName(&quot;/blog/write&quot;); 在组成url路径时会构成一个双斜杠//，在IDEA中运行时是可以被识别的，但在程序打包运行之后就不能被识别了，所以会出现这个问题。 解决办法根据上面的错误原因分析，目前的解决办法就是让模板的路径中不会出现双斜杠//，或者支持双斜杠//路径(目前已经有人在jira中提出了该bug 期待在之后的版本中能狗支持双斜杠//路径) 去掉返回视图页面最前面的斜杠： mav.setViewName(&quot;/blog/write&quot;); 改为 mav.setViewName(&quot;blog/write&quot;); 或者在配置文件里去掉最后的斜杠： spring.thymeleaf.prefix=classpath:/templates/ 改为 spring.thymeleaf.prefix=classpath:/templates 同时需要修改thymeleaf模板文件中的相关内容，比如 layout:decorate=&quot;~{blog/common/common} 此时应变为 layout:decorate=&quot;~{/blog/common/common}","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.wf2311.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.wf2311.com/tags/SpringBoot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://www.wf2311.com/tags/thymeleaf/"}]},{"title":"Java NIO源码分析之Buffer","slug":"Java NIO源码分析之Buffer","date":"2017-07-20T11:19:19.000Z","updated":"2018-01-15T13:57:36.452Z","comments":true,"path":"Java NIO源码分析之Buffer.html","link":"","permalink":"https://www.wf2311.com/Java NIO源码分析之Buffer.html","excerpt":"","text":"Buffer是特定基元类型数据的容器Buffer(缓冲区)是一种特定基元类型的线性、有限序列。除了内容之外，缓冲区的基本属性是capacity(容量)、limit(上限)和position(位置)以及mark(标记): capacity 缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。limit 缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。position 下一个要被读或写的元素的索引。位置会自动由相应的get()和put()函数更新。mark 一个备忘位置。调用mark()来设定mark = postion。调用reset()设定position = mark。标记在设定前是未定义的(undefined)。这四个属性之间总是遵循以下关系：10 &lt;= mark &lt;= position &lt;= limit &lt;= capacity","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wf2311.com/categories/Java/"}],"tags":[{"name":"nio","slug":"nio","permalink":"https://www.wf2311.com/tags/nio/"}]},{"title":"Git常用操作命令","slug":"Git常用操作命令","date":"2017-07-19T09:24:22.000Z","updated":"2018-01-15T13:57:36.451Z","comments":true,"path":"Git常用操作命令.html","link":"","permalink":"https://www.wf2311.com/Git常用操作命令.html","excerpt":"","text":"克隆远程制定分支到本地1git clone -b &lt;branch&gt; &lt;remote_repo&gt; ## branch为分支名，remote_repo为远程仓库 标签相关切换到指定分支1git checkout &lt;branch&gt; 检出指定分支1git checkout tags/&lt;tag_name&gt; -b &lt;branch_name&gt; 新建标签1git tag &lt;tagName&gt; 查看所有标签1git tag","categories":[{"name":"其它","slug":"其它","permalink":"https://www.wf2311.com/categories/其它/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.wf2311.com/tags/git/"},{"name":"常用命令","slug":"常用命令","permalink":"https://www.wf2311.com/tags/常用命令/"}]},{"title":"HttpServletRequest常用获取URL的方法","slug":"HttpServletRequest常用获取URL的方法","date":"2017-07-17T02:56:50.000Z","updated":"2018-01-15T13:57:36.451Z","comments":true,"path":"HttpServletRequest常用获取URL的方法.html","link":"","permalink":"https://www.wf2311.com/HttpServletRequest常用获取URL的方法.html","excerpt":"","text":"1、request.getRequestURL()返回的是完整的url，包括Http协议，端口号，servlet名字和映射路径，但它不包含请求参数。2、request.getRequestURI()得到的是request URL的部分值，并且web容器没有decode过的3、request.getContextPath()返回 the context of the request.4、request.getServletPath()返回调用servlet的部分url.5、request.getQueryString()返回url路径后面的查询字符串 示例： 当前url：http://localhost:8080/CarsiLogCenter_new/idpstat.jsp?action=idp.sptopn request.getRequestURL() http://localhost:8080/CarsiLogCenter_new/idpstat.jsp request.getRequestURI() /CarsiLogCenter_new/idpstat.jsp request.getContextPath()/CarsiLogCenter_new request.getServletPath() /idpstat.jsp request.getQueryString()action=idp.sptopn","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://www.wf2311.com/categories/Java-Web/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://www.wf2311.com/tags/Servlet/"},{"name":"HttpServletRequest","slug":"HttpServletRequest","permalink":"https://www.wf2311.com/tags/HttpServletRequest/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"https://www.wf2311.com/tags/SpringMvc/"}]},{"title":"使用thymeleaf变量给onclick属性赋值","slug":"使用thymeleaf变量给onclick属性赋值","date":"2017-07-15T01:47:13.000Z","updated":"2018-01-15T13:57:36.451Z","comments":true,"path":"使用thymeleaf变量给onclick属性赋值.html","link":"","permalink":"https://www.wf2311.com/使用thymeleaf变量给onclick属性赋值.html","excerpt":"","text":"在使用thymeleaf渲染页面时，遇到如下情况：1&lt;button onclick=\"submit('publish');\"&gt;提交&lt;/button&gt; submit函数的参数会根据后端参数的不同而动态改变，Google搜索到了一些类似问题，记录一下解决方法。 已经测试可用的：1th:onclick=\"'alert(\\'' + $&#123;myVar&#125; + '\\');'\" 还未测试：12345&lt;button th:onclick=\"'javascript:upload(' + $&#123;gallery&#125; + ')'\"&gt;&lt;/button&gt;th:onclick=\"|upload('$&#123;command['class'].simpleName&#125;', '$&#123;gallery&#125;')|\"&lt;div th:style=\"'background:url(' + @&#123;/&lt;path-to-image&gt;&#125; + ');'\"&gt;&lt;/div&gt;","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://www.wf2311.com/categories/Java-Web/"}],"tags":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://www.wf2311.com/tags/thymeleaf/"}]},{"title":"MySQL 优化之 index merge(索引合并)","slug":"MySQL 优化之 index merge(索引合并)","date":"2017-07-14T08:09:10.000Z","updated":"2018-01-15T13:57:36.450Z","comments":true,"path":"MySQL 优化之 index merge(索引合并).html","link":"","permalink":"https://www.wf2311.com/MySQL 优化之 index merge(索引合并).html","excerpt":"","text":"深入理解 index merge 是使用索引进行优化的重要基础之一。理解了 index merge 技术，我们才知道应该如何在表上建立索引。 1. 为什么会有index merge我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。 MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描。 相关文档：http://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html (注意该文档中说的有几处错误) The Index Merge method is used to retrieve rows with several range scans and to merge their results into one. The merge can produce unions, intersections, or unions-of-intersections of its underlying scans. This access method merges index scans from a single table; it does not merge scans across multiple tables. In EXPLAIN output, the Index Merge method appears as index_merge in the type column. In this case, the key column contains a list of indexes used, and key_len contains a list of the longest key parts for those indexes. index merge: 同一个表的多个索引的范围扫描可以对结果进行合并，合并方式分为三种：union, intersection, 以及它们的组合(先内部intersect然后在外面union)。 官方文档给出了四个例子：1234SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;SELECT * FROM tbl_name WHERE (key1 = 10 OR key2 = 20) AND non_key=30;SELECT * FROM t1, t2 WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%') AND t2.key1=t1.some_col;SELECT * FROM t1, t2 WHERE t1.key1=1 AND (t2.key1=t1.some_col OR t2.key2=t1.some_col2); 但是第四个例子，感觉并不会使用 index merge. 因为 t2.key1=t1.some_col 和 t2.key2=t1.some_col2 之间进行的是 OR 运算，而且 t2.key2 是复合索引的第二个字段(非第一个字段)。所以：t2.key2 = t1.some_col2 并不能使用到复合索引。(文档这里应该是错误的) index merge 算法根据合并算法的不同分成了三种：intersect, union, sort_union. 2. index merge 之 intersect简单而言，index intersect merge就是多个索引条件扫描得到的结果进行交集运算。显然在多个索引提交之间是 AND 运算时，才会出现 index intersect merge. 下面两种where条件或者它们的组合时会进行 index intersect merge: 1) 条件使用到复合索引中的所有字段或者左前缀字段(对单字段索引也适用) key_part1=const1 AND key_part2=const2 … AND key_partN=constN2) 主键上的任何范围条件 例子： 12SELECT * FROM innodb_table WHERE primary_key &lt; 10 AND key_col1=20;SELECT * FROM tbl_name WHERE (key1_part1=1 AND key1_part2=2) AND key2=2; 上面只说到复合索引，但是其实单字段索引显然也是一样的。比如 select * from tab where key1=xx and key2 =xxx; 也是有可能进行index intersect merge的。另外上面两种情况的 AND 组合也一样可能会进行 index intersect merge. The Index Merge intersection algorithm performs simultaneous scans on all used indexes and produces the intersection of row sequences that it receives from the merged index scans. (intersect merge运行方式：多个索引同时扫描，然后结果取交集) If all columns used in the query are covered by the used indexes, full table rows are not retrieved (EXPLAIN output contains Using index in Extra field in this case). Here is an example of such a query:(索引覆盖扫描，无需回表) 1SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1; If the used indexes do not cover all columns used in the query, full rows are retrieved only when the range conditions for all used keys are satisfied.(索引不能覆盖，则对满足条件的再进行回表) If one of the merged conditions is a condition over a primary key of an InnoDB table, it is not used for row retrieval, but is used to filter out rows retrieved using other conditions. 3. index merge 之 union简单而言，index uion merge就是多个索引条件扫描，对得到的结果进行并集运算，显然是多个条件之间进行的是 OR 运算。 下面几种类型的 where 条件，以及他们的组合可能会使用到 index union merge算法： 1) 条件使用到复合索引中的所有字段或者左前缀字段(对单字段索引也适用) 2) 主键上的任何范围条件 3) 任何符合 index intersect merge 的where条件； 上面三种 where 条件进行 OR 运算时，可能会使用 index union merge算法。 例子： SELECT FROM t1 WHERE key1=1 OR key2=2 OR key3=3;SELECT FROM innodb_table WHERE (key1=1 AND key2=2) OR (key3=’foo’ AND key4=’bar’) AND key5=5;第一个例子，就是三个 单字段索引 进行 OR 运算，所以他们可能会使用 index union merge算法。 第二个例子，复杂一点。(key1=1 AND key2=2) 是符合 index intersect merge; (key3=’foo’ AND key4=’bar’) AND key5=5 也是符合index intersect merge，所以 二者之间进行 OR 运算，自然可能会使用 index union merge算法。 4. index merge 之 sort_unionThis access algorithm is employed when the WHERE clause was converted to several range conditions combined by OR, but for which the Index Merge method union algorithm is not applicable.(多个条件扫描进行 OR 运算，但是不符合 index union merge算法的，此时可能会使用 sort_union算法) 官方文档给出了两个例子： SELECT FROM tbl_name WHERE key_col1 &lt; 10 OR key_col2 &lt; 20;SELECT FROM tbl_name WHERE (key_col1 &gt; 10 OR key_col2 = 20) AND nonkey_col=30;但是显然：因为 key_col2 不是复合索引的第一个字段，对它进行 OR 运算，是不可能使用到索引的。所以这两个例子应该也是错误的，它们实际上并不会进行 index sort_union merge算法。 The difference between the sort-union algorithm and the union algorithm is that the sort-union algorithm must first fetch row IDs for all rows and sort them before returning any rows.(sort-union合并算法和union合并算法的不同点，在于返回结果之前是否排序，为什么需要排序呢？可能是因为两个结果集，进行并集运算，需要去重，所以才进行排序？？？) 5. index merge的局限1）If your query has a complex WHERE clause with deep AND/OR nesting and MySQL does not choose the optimal plan, try distributing terms using the following identity laws: (x AND y) OR z = (x OR z) AND (y OR z)(x OR y) AND z = (x AND z) OR (y AND z)如果我们的条件比较复杂，用到多个 and / or 条件运算，而MySQL没有使用最优的执行计划，那么可以使用上面的两个等式将条件进行转换一下。 2）Index Merge is not applicable to full-text indexes. We plan to extend it to cover these in a future MySQL release.(全文索引没有index merge) 3）Before MySQL 5.6.6, if a range scan is possible on some key, the optimizer will not consider using Index Merge Union or Index Merge Sort-Union algorithms. For example, consider this query: SELECT * FROM t1 WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND badkey &lt; 30;For this query, two plans are possible: An Index Merge scan using the (goodkey1 &lt; 10 OR goodkey2 &lt; 20) condition. A range scan using the badkey &lt; 30 condition. However, the optimizer considers only the second plan. 这一点对以低版本的MySQL是一个很大的缺陷。就是如果where条件中有 &gt;, &lt;, &gt;=, &lt;=等条件，那么优化器不会使用 index merge，而且还会忽略其他的索引，不会使用它们，哪怕他们的选择性更优。 6. 对 index merge 的进一步优化index merge使得我们可以使用到多个索引同时进行扫描，然后将结果进行合并。听起来好像是很好的功能，但是如果出现了 index intersect merge，那么一般同时也意味着我们的索引建立得不太合理，因为 index intersect merge 是可以通过建立 复合索引进行更一步优化的。 比如下面的select: SELECT * FROM t1 WHERE key1=1 AND key2=2 AND key3=3;显然我们是可以在这三个字段上建立一个复合索引来进行优化的，这样就只需要扫描一个索引一次，而不是对三个所以分别扫描一次。 percona官网有一篇 比较复合索引和index merge 的好文章：Multi Column indexes vs Index Merge 7. 复合索引的最左前缀原则上面我们说到，对复合索引的非最左前缀字段进行 OR 运算，是无法使用到复合索引的。比如： SELECT * FROM tbl_name WHERE (key_col1 &gt; 10 OR key_col2 = 20) AND nonkey_col=30;其原因是，MySQL中的索引，使用的是B+tree, 也就是说他是：先按照复合索引的 第一个字段的大小来排序，插入到 B+tree 中的，当第一个字段值相同时，在按照第二个字段的值比较来插入的。那么如果我们需要对： OR key_col2 = 20 这样的条件也使用复合索引，那么该怎么操作呢？应该要对复合索引进行全扫描，找出所有 key_col2 =20 的项，然后还要回表去判断 nonkey_col=30，显然代价太大了。所以一般而言 OR key_col2 = 20 这样的条件是无法使用到复合索引的。如果一定要使用索引，那么可以在 col2 上单独建立一个索引。 复合索引的最左前缀原则： MySQL中的复合索引，查询时只会使用到最左前缀，比如：1234567891011121314 mysql&gt; show index from role_goods; +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | role_goods | 0 | PRIMARY | 1 | id | A | 22816 | NULL | NULL | | BTREE | | | | role_goods | 1 | roleId | 1 | roleId | A | 1521 | NULL | NULL | YES | BTREE | | | | role_goods | 1 | goodsId | 1 | goodsId | A | 1521 | NULL | NULL | YES | BTREE | | | | role_goods | 1 | roleId_2 | 1 | roleId | A | 1901 | NULL | NULL | YES | BTREE | | | | role_goods | 1 | roleId_2 | 2 | status | A | 4563 | NULL | NULL | YES | BTREE | | | | role_goods | 1 | roleId_2 | 3 | number | A | 22816 | NULL | NULL | YES | BTREE | | | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+6 rows in set (0.00 sec) 上面有一个复合索引：roleId_2(roleId,status,number)，如果条件是： where roleId=xxx and number=xxx，那么此时只会使用到最左前缀roleId，而不会使用到 number 来进行过滤。因为它们中间存在一个字段 status 没有出现在where条件中。实验如下所示： 123456789101112131415161718192021222324252627282930mysql&gt; explain select * from role_goods where roleId=100000001 and status=1 and number=1 limit 1;+----+-------------+------------+------+-----------------+----------+---------+-------------------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+------+-----------------+----------+---------+-------------------+------+-------+| 1 | SIMPLE | role_goods | ref | roleId,roleId_2 | roleId_2 | 23 | const,const,const | 13 | NULL |+----+-------------+------------+------+-----------------+----------+---------+-------------------+------+-------+1 row in set (0.00 sec)mysql&gt; explain select * from role_goods where roleId=100000001 and status=1 limit 1;+----+-------------+------------+------+-----------------+----------+---------+-------------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+------+-----------------+----------+---------+-------------+------+-------+| 1 | SIMPLE | role_goods | ref | roleId,roleId_2 | roleId_2 | 14 | const,const | 13 | NULL |+----+-------------+------------+------+-----------------+----------+---------+-------------+------+-------+1 row in set (0.00 sec)mysql&gt; explain select * from role_goods where roleId=100000001 and number=1 limit 1;+----+-------------+------------+------+-----------------+--------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+------+-----------------+--------+---------+-------+------+-------------+| 1 | SIMPLE | role_goods | ref | roleId,roleId_2 | roleId | 9 | const | 14 | Using where |+----+-------------+------------+------+-----------------+--------+---------+-------+------+-------------+1 row in set (0.01 sec)mysql&gt; explain select * from role_goods ignore index(roleId) where roleId=100000001 and number=1 limit 1;+----+-------------+------------+------+---------------+----------+---------+-------+------+-----------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+------+---------------+----------+---------+-------+------+-----------------------+| 1 | SIMPLE | role_goods | ref | roleId_2 | roleId_2 | 9 | const | 14 | Using index condition |+----+-------------+------------+------+---------------+----------+---------+-------+------+-----------------------+1 row in set (0.01 sec) 可以看到 key_len 的变化： 显然最后一个查询仅仅使用到符合索引中的 roleId, 没有使用到 number. number使用在了 index conditon(也就是索引的push down技术) 注意最左前缀，并不是是指：一定要按照各个字段出现在where中的顺序来建立复合索引的。比如1where status=2 and roleId=xxx and number = xxx 该条件建立符合索引，我们并不需要按照status,roleId，number它们出现的顺序来建立索引：1alter table role_goods add index sin(status,roleId,number) 这是对最左前缀极大的误解。因为 where status=2 and roleId=xxx and number = xxx 和 where roleId=xxx and number = xxx and status=2它们是等价的。复合索引，哪个字段放在最前面，需要根据哪个字段经常出现在where条件中，哪个字段的选择性最好来判断的。 进一步可以参考的文章： http://www.orczhou.com/index.php/2013/01/mysql-source-code-query-optimization-index-merge/ http://www.cnblogs.com/nocode/archive/2013/01/28/2880654.html","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.wf2311.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.wf2311.com/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"https://www.wf2311.com/tags/索引/"}]},{"title":"测试markdown语法","slug":"测试markdown语法","date":"2017-07-14T08:01:18.000Z","updated":"2018-01-15T13:57:36.447Z","comments":true,"path":"测试markdown语法.html","link":"","permalink":"https://www.wf2311.com/测试markdown语法.html","excerpt":"","text":"欢迎使用马克飞象@(Pro)[马克飞象, 帮助, Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#x68;&#117;&#x73;&#x74;&#x67;&#x6f;&#x63;&#x6b;&#64;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#x6d; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","categories":[{"name":"其它","slug":"其它","permalink":"https://www.wf2311.com/categories/其它/"}],"tags":[{"name":"test","slug":"test","permalink":"https://www.wf2311.com/tags/test/"},{"name":"Markdown","slug":"Markdown","permalink":"https://www.wf2311.com/tags/Markdown/"}]},{"title":"在SpringBoot里面使用thymeleaf3","slug":"在SpringBoot里面使用thymeleaf3","date":"2017-05-26T01:53:26.000Z","updated":"2018-01-15T13:57:36.450Z","comments":true,"path":"在SpringBoot里面使用thymeleaf3.html","link":"","permalink":"https://www.wf2311.com/在SpringBoot里面使用thymeleaf3.html","excerpt":"","text":"最近在一个springboot项目里使用thymeleaf模板，访问页面时一直报错。而之前的项目中没发现过这种情况发生。和之前的项目对比发现，在springboot项目中引入1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 引入的thymeleaf版本居然是2.x.x版本，之前项目引入的是3.x.x版本的 之前项目 该项目 查看相应的pom文件发现，thymeleaf.version确实是2.x.x的。 截图 究竟怎么回事呢？搜索springboot文档中相关thymeleaf的段落，发现了如下描述: 描述 原来在spring-boot-starter-thymeleaf中默认引入的版本thymeleaf是2.1,如果需要使用thymeleaf3,需要在pom.xml中加入如下配置：1234&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.1.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.wf2311.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://www.wf2311.com/tags/SpringBoot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://www.wf2311.com/tags/thymeleaf/"}]},{"title":"Runnable实现资源共享","slug":"Runnable实现资源共享","date":"2017-05-25T09:03:18.000Z","updated":"2018-01-15T13:57:36.449Z","comments":true,"path":"Runnable实现资源共享.html","link":"","permalink":"https://www.wf2311.com/Runnable实现资源共享.html","excerpt":"","text":"参考地址 以抢票或秒杀为例 错误示例1： Service 12345678910111213class Service implements Runnable &#123; private int remain = 100; public AtomicInteger count = new AtomicInteger(0); @Override public void run() &#123; while (remain &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \" 剩余：\" + this.remain--); count.addAndGet(1); &#125; &#125;&#125; 测试方法： 12345678910111213141516171819202122232425public class Main &#123; public static int buy() throws InterruptedException &#123; Service service = new Service(); Thread[] threads = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(service); &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); &#125; Thread.sleep(50); return service.count.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; int[] array = new int[100]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = buy(); &#125; long a = Arrays.stream(array).filter(i -&gt; i &gt; 100).count(); System.out.println(\"执行次数大于100的个数：\" + a); &#125;&#125; 测试结果： 截图 执行100次中出现了13次下单次数大于100次的情况 原因分析:在上述方法中，多个线程共享一个变量，会存在并发争抢资源的问题，可能多买票的现象。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wf2311.com/categories/Java/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://www.wf2311.com/tags/thread/"},{"name":"java","slug":"java","permalink":"https://www.wf2311.com/tags/java/"}]},{"title":"jquery checkbox选中、改变状态、change和click事件","slug":"jquery checkbox选中、改变状态、change和click事件","date":"2017-05-25T02:55:13.000Z","updated":"2018-01-15T13:57:36.449Z","comments":true,"path":"jquery checkbox选中、改变状态、change和click事件.html","link":"","permalink":"https://www.wf2311.com/jquery checkbox选中、改变状态、change和click事件.html","excerpt":"","text":"原文 jquery判断checked的三种方法: 123.attr('checked'); //看版本1.6+返回:”checked”或”undefined” ;1.5-返回:true或false.prop('checked'); //1.6+:true/false.is(':checked'); //所有版本:true/false//别忘记冒号哦 jquery赋值checked的几种写法: 123456789101112//所有的jquery版本都可以这样赋值:$(\"#cb1\").attr(\"checked\", \"checked\");$(\"#cb1\").attr(\"checked\", true);//jquery1.6+:prop的4种赋值:$(\"#cb1\").prop(\"checked\", true);$(\"#cb1\").prop(&#123;checked: true&#125;);$(\"#cb1\").prop(\"checked\", function () &#123; return true;//函数返回true或false&#125;);//记得还有这种哦:$(\"#cb1″).prop(\"checked\",\"checked\"); checkbox click和change事件 123456789101112131415161718192021222324252627282930313233343536//方法1:$(\"#ischange\").change(function () &#123; alert(\"checked\");&#125;);//方法2:$(function () &#123; if ($.browser.msie) &#123; $('input:checkbox').click(function () &#123; this.blur(); this.focus(); &#125;); &#125;&#125;);//方法3：$(\"#ischange\").change(function () &#123; alert(\"checked\");&#125;);//方法4:$(function () &#123; if ($.browser.msie) &#123; $('input:checkbox').click(function () &#123; this.blur(); this.focus(); &#125;); &#125;&#125;);//方法5:$(document).ready(function () &#123; $(\"testCheckbox\").change(function () &#123; alert(\"Option changed!\"); &#125;);&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://www.wf2311.com/categories/前端/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://www.wf2311.com/tags/jquery/"}]},{"title":"nginx出现413 Request Entity Too Large 解决方法","slug":"nginx出现413 Request Entity Too Large 解决方法","date":"2017-05-24T07:50:14.000Z","updated":"2018-01-15T13:57:36.449Z","comments":true,"path":"nginx出现413 Request Entity Too Large 解决方法.html","link":"","permalink":"https://www.wf2311.com/nginx出现413 Request Entity Too Large 解决方法.html","excerpt":"","text":"nginx.conf中默认没有设置client_max_body_size，这个参数默认只是1M，解决办法：增加如下两行到nginx.conf的http{}段， 增大nginx上传文件大小限制123#设置允许发布内容为8Mclient_max_body_size 8M;client_body_buffer_size 128k;","categories":[{"name":"其它","slug":"其它","permalink":"https://www.wf2311.com/categories/其它/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://www.wf2311.com/tags/nginx/"}]},{"title":"水仙花算法","slug":"水仙花算法","date":"2017-05-23T03:24:15.000Z","updated":"2018-01-15T13:57:36.448Z","comments":true,"path":"水仙花算法.html","link":"","permalink":"https://www.wf2311.com/水仙花算法.html","excerpt":"","text":"算法描述 水仙花数是一个n(&gt;=3)位数字的数,它等于每个数字的n次幂之和 列如153分别是1 5 3 这几个数的立方之和 算法实现12345678910111213141516171819202122232425262728293031323334353637/** * 计算从100到endNum范围内的水仙花数 */public int[] narcissisticNumber(int endNum) &#123; return IntStream.range(100, endNum).parallel() //判断n是否为水仙花数 .filter(n -&gt; isNarcissistic(n)) //得到结 果作为数值返回 .toArray();&#125;/** * 判断一个整数是否是水仙花数 */private boolean isNarcissistic(int n) &#123; //切割整数 String[] array = String.valueOf(n).split(\"\"); int sum = Arrays.stream(array) //n次方 .mapToInt(i -&gt; nPower(Integer.valueOf(i), array.length)) //求和 .sum(); return sum == n;&#125;/** * 计算n次方 */public int nPower(int i, int n) &#123; int sum = 1; while (n &gt; 0) &#123; sum *= i; n--; &#125; return sum;&#125; 测试12345678/** * 计算1_0000_0000以内的水仙花数 */@Testpublic void test() &#123; int[] ints = narcissisticNumber(1_0000_0000); Arrays.stream(ints).forEach(System.out::println);&#125; 输出1234567891011121314151617181533703714071634820894745474892727930845488341741725421081898008179926315246780502467805188593477","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wf2311.com/categories/Java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"https://www.wf2311.com/tags/java8/"},{"name":"算法","slug":"算法","permalink":"https://www.wf2311.com/tags/算法/"}]},{"title":"java8中利用Stream过滤属性重复的元素","slug":"java8中利用Stream过滤属性重复的元素","date":"2017-05-23T03:10:08.000Z","updated":"2018-01-15T13:57:36.448Z","comments":true,"path":"java8中利用Stream过滤属性重复的元素.html","link":"","permalink":"https://www.wf2311.com/java8中利用Stream过滤属性重复的元素.html","excerpt":"","text":"根据属性过滤重复的元素参考地址1234567/** * 根据属性过滤重复的元素 */public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T,Object&gt; keyExtractor) &#123; Map&lt;Object,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;(); return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637static String[] data = new String[]&#123; \"1,2,a,4,5,6\", \"2,2,b,4,5,6\", \"3,2,a,4,5,6\", \"4,2,d,4,5,6\", \"5,2,b,5,5,6\", \"6,2,f,4,5,6\", \"7,2,c,4,5,6\", \"8,2,g,4,5,6\", \"9,2,d,4,5,6\", \"10,2,g,5,5,6\",&#125;;/** * 根据单个属性过滤 */@Testpublic void test1() &#123; int[] arrays = Stream.of(data).map(d -&gt; d.split(\",\")) .filter(array -&gt; !array[0].equals(\"1\")) .filter(distinctByKey(array -&gt; array[2])) .mapToInt(array -&gt; Integer.valueOf(array[0])) .toArray(); Assert.assertArrayEquals(new int[]&#123;2, 3, 4, 6, 7, 8&#125;, arrays);&#125;/** * 根据多个属性过滤 */@Testpublic void test2() &#123; int[] arrays = Stream.of(data).map(d -&gt; d.split(\",\")) .filter(distinctByKey(array -&gt; array[2] + array[3])) .mapToInt(array -&gt; Integer.valueOf(array[0])) .toArray(); Assert.assertArrayEquals(new int[]&#123;1, 2, 4, 5, 6, 7, 8, 10&#125;, arrays);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.wf2311.com/categories/Java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"https://www.wf2311.com/tags/java8/"},{"name":"stream","slug":"stream","permalink":"https://www.wf2311.com/tags/stream/"}]}]}