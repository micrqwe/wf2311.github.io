{"meta":{"title":"王峰的个人博客","subtitle":null,"description":null,"author":"王峰","url":"https://wangfeng.pro"},"pages":[{"title":"","date":"2018-01-12T12:02:36.994Z","updated":"2018-01-12T12:02:36.993Z","comments":false,"path":"categories/index.html","permalink":"https://wangfeng.pro/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-12T12:02:06.989Z","updated":"2018-01-12T12:02:06.988Z","comments":false,"path":"tags/index.html","permalink":"https://wangfeng.pro/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"有了Closeable为什么还要定义AutoCloseable","slug":"有了Closeable为什么还要定义AutoCloseable","date":"2017-09-27T01:24:31.000Z","updated":"2018-01-12T13:05:31.202Z","comments":true,"path":"a/有了Closeable为什么还要定义AutoCloseable/","link":"","permalink":"https://wangfeng.pro/a/有了Closeable为什么还要定义AutoCloseable/","excerpt":"","text":"从try-with-resources语法块说起我们知道java7中引入了新的语法块try-with-resources:实现了java.lang.AutoCloseable的对象都可以作为资源，在try后面的括号类声明实例化，在后面的{...}语句块执行完后被自动关闭(close()方法被自动调用)。例如：在java7前，我们需要这样定义语句:1234567891011121314public void writeFile(String path,byte[] data)&#123; OutputStream os = null; try &#123; os = new FileOutputStream(path); os.write(data); os.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (os!=null)&#123; os.close(); &#125; &#125;&#125; 而在java7后，可以变成这样：12345678public void writeFile(String path,byte[] data)&#123; try ( OutputStream os = new FileOutputStream(path))&#123; os.write(data); os.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; Closeable与AutoCloseable的关系与区别AutoCloseable的源码如下:123456/** * @since 1.7 */public interface AutoCloseable &#123; void close() throws Exception;&#125; Closeable的源码如下:123456/** * @since 1.5 */public interface Closeable extends AutoCloseable &#123; public void close() throws IOException;&#125; 由上可知Closeable在jdk1.5中就定义了，而AutoCloseable在jdk1.7才被引入，并且Closeable继承了AutoCloseable。为什么要这样设计呢？答案很简单，仔细查看源码就可以知道原因:因为Closeable的close()方法只会抛出IOException异常，而AutoCloseable的close()方法抛出的是Exception异常。如此一来try-with-resources的适用性就更大了。 参考 https://stackoverflow.com/questions/19572537/why-is-autocloseable-the-base-interface-for-closeable-and-not-vice-versa","categories":[{"name":"Java","slug":"Java","permalink":"https://wangfeng.pro/categories/Java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://wangfeng.pro/tags/java基础/"},{"name":"io","slug":"io","permalink":"https://wangfeng.pro/tags/io/"}]},{"title":"IDEA 远程调试spring boot项目","slug":"IDEA 远程调试spring boot项目","date":"2017-09-21T01:33:52.000Z","updated":"2018-01-12T12:08:31.393Z","comments":true,"path":"a/IDEA 远程调试spring boot项目/","link":"","permalink":"https://wangfeng.pro/a/IDEA 远程调试spring boot项目/","excerpt":"","text":"IDEA 远程调试spring boot项目1. Dokcer容器中在Dockefile中配置(方法1)在Dockerfile文件中加入参数-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n,例如：123...ENV JAVA_OPTS=\"-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=n\"ENTRYPOINT [ \"sh\", \"-c\", \"java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar\" ] 启动docker命令：1docker run -p 8000:8000 -p 4000:4000 -t imageName 参数说明： -p 8000:8000 表示把在Dockerfile中定义的远程调试端口8000映射到服务器端口8000中； -p 4000:4000 表示把在应用程序的启动端口4000映射到服务器端口4000中；启动命令中配置(方法2)在启动命令中加上参数-e &quot;JAVA_OPTS=-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=y&quot;，例如：1docker run -e \"JAVA_OPTS=-agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=y\" -p 8000:8000 -p 4000:4000 -t imageName 2. 以嵌入式web容器运行时在启动命令中加上参数-e &quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000，例如：1java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000 -jar application.jar 3. 以mvn spring-boot:run运行时在pom.xml中加入如下插件:123456789&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;jvmArguments&gt; -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 &lt;/jvmArguments&gt; &lt;/configuration&gt;&lt;/plugin&gt; 参考资料 debug spring-boot in docker spring boot + IDEA 远程调试 Spring Boot Maven Plugin - Debug the application","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wangfeng.pro/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wangfeng.pro/tags/SpringBoot/"},{"name":"远程调试","slug":"远程调试","permalink":"https://wangfeng.pro/tags/远程调试/"}]},{"title":"spring boot + IDEA 远程调试","slug":"spring boot + IDEA 远程调试","date":"2017-09-19T02:20:54.000Z","updated":"2018-01-12T12:08:31.393Z","comments":true,"path":"a/spring boot + IDEA 远程调试/","link":"","permalink":"https://wangfeng.pro/a/spring boot + IDEA 远程调试/","excerpt":"","text":"配置若想调试远端web容器内部的应用，需要接入web容器的jvm，以Tomcat为例，需修改web容器的配置1234567// bin\\startup.bat（.sh）文件，在里面添加 // windowsset CATALINA_OPTS=\"-agentlib:jdwp=transport=dt_socket,address=8888（自定义调试端口）,server=y,suspend=n %CATALINA_OPTS%\" // linuxexport CATALINA_OPTS=\"-agentlib:jdwp=transport=dt_socket,address= 8888（自定义调试端口）,server=y,suspend=n $CATALINA_OPTS\" 若是使用了spring boot并将工程打成了可执行JAR包12345// 在使用java指令启动程序时需要附加额外的参数以开启外部调试，如下-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8888（自定义调试端口） // 完整的启动指令是类似下面酱的java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8888（自定义调试端口） -jar application.jar IDEA连接远端调试 填写远端JMV所在服务器IP和调试端口号，保存即可： 连接远端JVM启动调试： 如若连接成功，调试控制台将输出以下内容，如果没成功，请自行检查服务器防火墙以及网络 接下来的操作就和在本地调试一样了，打断点，远端JVM会通过网络同步调试信息，和在本地没什么两样，要注意调试的时候和本地一样都是会暂停JVM继续往下执行的。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wangfeng.pro/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wangfeng.pro/tags/SpringBoot/"},{"name":"远程调试","slug":"远程调试","permalink":"https://wangfeng.pro/tags/远程调试/"}]},{"title":"Java面试题","slug":"Java面试题","date":"2017-09-18T02:18:21.000Z","updated":"2018-01-12T12:08:31.392Z","comments":true,"path":"a/Java面试题/","link":"","permalink":"https://wangfeng.pro/a/Java面试题/","excerpt":"","text":"JAVA基础 JAVA中的几种基本数据类型是什么，各自占用多少字节。 String类能被继承吗，为什么。 String，Stringbuffer，StringBuilder的区别。 ArrayList和LinkedList有什么区别。 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。 JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。 有没顺序的 有没顺序的 有没顺序的 有没顺序的 MapMap 实现类 实现类 ，如果有 如果有 ，他们是怎么保证有序的 他们是怎么保证有序的 他们是怎么保证有序的 他们是怎么保证有序的 他们是怎么保证有序的 。 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。 继承和聚合的区别在哪。 IO模型有哪些，讲讲你理解的nio，他和bio的区别是啥，谈谈reactor模型。 反射的原理，反射创建类实例的三种方式是什么。 反射中，Class.forName和ClassLoader区别。 描述动态代理的几种实现方式，分别说出相应的优缺点。 动态代理与cglib实现的区别。 为什么CGlib方式可以对接口实现代理。 final的用途。 写出三种单例模式实现。 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。 深拷贝和浅拷贝区别。 数组和链表数据结构描述，各自的时间复杂度。 error和exception的区别，CheckedException，RuntimeException的区别。 请列出5个运行时异常。 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。 有没可能 有没可能 有没可能 2个不相等的 对象有同个不相等的 对象有同个不相等的 对象有同个不相等的 对象有同个不相等的 对象有同个不相等的 对象有同hashcode hashcodehashcode hashcodehashcode 。 Java中的HashSet内部是如何工作的。 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。 java8的新特性。 JVM知识 什么情况下会发生栈内存溢出。 JVM的内存结构，Eden和Survivor比例。 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。 垃圾回收算法的实现原理。 当出现了内存溢出，你怎么排错。 JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。 讲讲JAVA的反射机制。 你们线上应用的JVM参数有哪些。 g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。 怎么打出线程栈信息。 请解释如下jvm参数的含义： -server -Xms512m -Xmx512m -Xss1024K -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxTenuringThreshold=20XX:MaxTenuringThreshold=20 XX:MaxTenuringThreshold=20XX:MaxTenuringThreshold=20 XX:MaxTenuringThreshold=20 XX:MaxTenuringThreshold=20 XX:MaxTenuringThreshold=20 XX:MaxTenuringThreshold=20 XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly。 开源框架知识 简单讲讲tomcat结构，以及其类加载器流程。 tomcat如何调优，涉及哪些参数。 讲讲Spring加载流程。 讲讲Spring事务的传播属性。 Spring如何管理事务的。 Spring怎么配置事务（具体说出一些关键的xml 元素）。 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。 Springmvc 中DispatcherServlet初始化过程。 netty的线程模型 netty的线程模型netty如何基于reactor模型上实现的。 netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。 netty的心跳处理在弱网下怎么办。 netty的通讯协议是什么样的。 操作系统 Linux系统下你关注过哪些内核参数，说说你知道的。 Linux下IO模型有几种，各自的含义是什么。 epoll和poll有什么区别。 平时用到哪些Linux命令。 用一行命令查看文件的最后五行。 用一行命令输出正在运行的java进程。 介绍下你理解的操作系统中线程切换过程。 进程和线程的区别。 top 命令之后有哪些内容，有什么作用。 多线程 多线程的几种实现方式，什么是线程安全。 volatile的原理，作用，能代替锁么。 画一个线程的生命周期状态图。 sleep和wait的区别。 Lock与Synchronized的区别。 synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗)解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。 用过哪些原子类，他们的原理是什么。 JUC下研究过哪些并发工具，讲讲原理。 用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。 线程池的关闭方式有几种，各自的区别是什么。 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。 spring的controller是单例还是多例，怎么保证并发的安全。 用三个线程按顺序循环打印abc三个字母，比如abcabcabc。 ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。 如果让你实现一个并发安全的链表，你会怎么做。 有哪些无锁数据结构，他们实现的原理是什么。 讲讲java同步机制的wait和notify。 多线程如果线程挂住了怎么办。 countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如countdownlatch的await方法和是怎么实现的)。 对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所加锁有什么不同。 使用synchronized修饰静态方法和非静态方法有什么区别。 简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。 导致线程死锁的原因？怎么解除线程死锁。 非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。 用过读写锁吗，原理是什么，一般在什么场景下用。 开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。 延迟队列的实现方式，delayQueue和时间轮算法的异同。 TCP与HTTP http1.0和http1.1有什么区别。 TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。 TIME_WAIT和CLOSE_WAIT的区别。 说说你知道的几种HTTP响应码，比如200, 302, 404。 当你用浏览器打开一个链接的时候，计算机做了哪些工作步骤。 TCP/IP如何保证可靠性，说说TCP头的结构。 7. 如何避免浏览器缓存。 简述Http请求get和post的区别以及数据包格式。 简述HTTP请求的报文格式。 HTTPS的加密方式是什么，讲讲整个加密解密流程。 架构设计与分布式 常见的缓存策略有哪些，如何做到缓存与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。 用java自己实现一个LRU。 分布式集群下如何做到唯一序列号。 设计一个秒杀系统，30分钟没付款就自动关闭交易。 如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里） 如果有人恶意创建非法连接，怎么解决。 分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。 什么是一致性hash。 什么是restful，讲讲你理解的restful。 如何设计建立和保持100w的长连接。 如何防止缓存击穿和雪崩。 解释什么是MESI协议(缓存一致性)。 说说你知道的几种HASH算法，简单的也可以。 什么是paxos算法，什么是zab协议。 一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。 线上系统突然变得异常缓慢，你如何查找问题。 说说你平时用到的设计模式。 Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现，重试转发，快速失败的策略是怎样的。 一次RPC请求的流程是什么。 自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。 异步模式的用途和意义。 缓存数据过期后的更新如何设计。 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。 设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。 MVC模式，即常见的MVC框架。 聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。 应用服务器怎么监控性能，各种方式的区别。 如何设计一套高并发支付方案，架构如何设计。 如何实现负载均衡，有哪些算法可以实现。 Zookeeper的用途，选举的原理是什么。 Zookeeper watch机制原理。 Mybatis的底层实现原理。 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。 请思考一个方案，实现分布式环境下的countDownLatch。 后台系统怎么防止请求重复提交。 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。本地缓存在并发使用时的注意事项。 描述一个服务从发布到被消费的详细过程。 讲讲你理解的服务治理。 如何做到接口的幂等性。 如何做限流策略，令牌桶和漏斗算法的使用场景。 什么叫数据一致性，你怎么理解数据一致性。 分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎么做到最小的资源浪费，流量半开的实现机制是什么。 dubbo的泛化调用怎么实现的，如果是你，你会怎么做。 算法 10亿个数字里里面找最小的10个。 有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。 2亿个随机生成的无序整数,找出中间大小的值。 给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。 遍历二叉树。 有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。 写一个字符串反转函数。 常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。 二分查找的时间复杂度，优势。 一个已经构建好的TreeSet，怎么完成倒排序。 什么是B+树，B-树，列出实际的使用场景。 一个单向链表，删除倒数第N个数据。 200个有序的数组，每个数组里面100个元素，找出top20的元素。 单向链表，查找中间的那个元素。 数据库知识 数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。 MYSQL有哪些存储引擎，各自优缺点。 3. 高并发下，如何做到安全的修改同一行数据。 乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。 5. SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。 6. 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。 7. MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。 8. 聚集索引和非聚集索引的区别。 9. select for update 是什么含义，会锁表还是锁行或是其他。 10. Btree怎么分裂的，什么时候分裂，为什么是平衡的。 11. 数据库的ACID是什么。 12. 某个表有近千万数据，CRUD比较慢，如何优化。 13. Mysql怎么优化table scan的。 14. 如何写sql能够有效的使用到复合索引。 15. mysql中in 和exists 区别。 16. 数据库自增主键可能的问题。 17. MVCC的含义。 消息队列 用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务架构怎样的。 MQ系统的数据如何保证不丢失。 rabbitmq如何实现集群高可用。 kafka吞吐量高的原因。 kafka 和其他消息队列的区别，kafka 主从同步怎么实现。 利用mq怎么实现最终一致性。 Redis，Memcached redis的list结构相关的操作。 Redis的数据结构都有哪些。 Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。 redis2和redis3的区别，redis3内部通讯机制。 当前redis集群有哪些玩法，各自优缺点，场景。 Memcache的原理，哪些数据适合放在缓存中。 redis和memcached 的内存管理的区别。 Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。 Redis的选举算法和流程是怎样的。 redis的持久化的机制，aof和rdb的区别。 redis的集群怎么同步的数据的。 知道哪些redis的优化操作。 搜索 elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch的倒排索引是什么。 elasticsearch索引数据多了怎么办，如何调优，部署。 lucence内部结构是什么。","categories":[{"name":"面试题","slug":"面试题","permalink":"https://wangfeng.pro/categories/面试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://wangfeng.pro/tags/面试题/"}]},{"title":"JetBrains插件推荐","slug":"JetBrains插件推荐","date":"2017-09-13T01:09:17.000Z","updated":"2018-01-12T12:08:31.392Z","comments":true,"path":"a/JetBrains插件推荐/","link":"","permalink":"https://wangfeng.pro/a/JetBrains插件推荐/","excerpt":"","text":"翻译插件TranslationPluginJetBrains IDE/Android Studio 翻译插件，支持中英互译、单词朗读。[项目主页] https://github.com/YiiGuxing/TranslationPlugin[插件下载地址] https://plugins.jetbrains.com/idea/plugin/8579","categories":[{"name":"其它","slug":"其它","permalink":"https://wangfeng.pro/categories/其它/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://wangfeng.pro/tags/插件/"},{"name":"app","slug":"app","permalink":"https://wangfeng.pro/tags/app/"}]},{"title":"Java的枚举类使用技巧","slug":"Java的枚举类使用技巧","date":"2017-08-02T06:05:07.000Z","updated":"2018-01-12T12:08:31.391Z","comments":true,"path":"a/Java的枚举类使用技巧/","link":"","permalink":"https://wangfeng.pro/a/Java的枚举类使用技巧/","excerpt":"","text":"枚举接口在web开发中我们常常会定义一些enum来表示常量，比如:1234567891011121314151617181920212223enum BlogType &#123; BLOG(1, \"原创博文\"), REPRINT(2, \"转载文章\"), QUESTION(3, \"问答\"), VOTE(4, \"投票\"), SUBJECT(5, \"专栏\"); private Integer code; private String name; BlogType(Integer code, String name) &#123; this.code = code; this.name = name; &#125; public Integer getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125;&#125; 以及:123456789101112131415161718192021enum BlogStatus &#123; PRIVATE(1, \"自己可见\"), FRIEND(2, \"好友可见\"), ONLINE(3, \"登陆用户可见\"), PUBLISH(4, \"公开\"); private Integer code; private String name; BlogStatus(Integer code, String name) &#123; this.code = code; this.name = name; &#125; public Integer getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125;&#125; 可以看出它们的结构一样，都有code和name这两个属性，以及对应的getter方法，因此可以定义一个如下的接口：123456public interface Common&lt;C, N&gt; &#123; C getCode(); N getName();&#125; 所有如上面的常量枚举类都可以实现该接口。1234567enum BlogType implements Common &#123; //...&#125;enum BlogStatus implements Common &#123; //...&#125; 公用静态方法我们可以在在Common接口中定义一个如下的静态方法：12345static &lt;E extends Enum&lt;E&gt; &amp; Common, C&gt; E getByCode(Class&lt;E&gt; clazz, C code) &#123; return Arrays.stream(clazz.getEnumConstants()) .filter(t -&gt; t.getCode().equals(code)) .findFirst().orElse(null);&#125; 使用此方法可以根据code来查找指定的Common实现类中的值，比如：12Assert.assertEquals(BlogType.QUESTION, Common.getByCode(BlogType.class, BlogType.QUESTION.getCode()));Assert.assertEquals(BlogStatus.PUBLISH, Common.getByCode(BlogType.class, BlogStatus.PUBLISH.getCode())); 自定义序列化当我们定义如下的方法123456789@GetMapping(\"/consts\")public ApiResult consts() &#123; ApiResult result = new ApiResult(); Map&lt;String, Object&gt; consts = new HashMap&lt;&gt;(); consts.put(\"blogType\", BlogType.values()); consts.put(\"blogStatus\", BlogStatus.values()); result.setData(consts); return result;&#125; 通过请求，得到的结果格式是12345678910111213141516171819&#123; \"code\": 0, \"success\": true, \"data\": &#123; \"blogStatus\": [ \"PRIVATE\", \"FRIEND\", \"ONLINE\", \"PUBLISH\" ], \"blogType\": [ \"BLOG\", \"REPRINT\", \"QUESTION\", \"VOTE\", \"SUBJECT\" ] &#125;&#125; 而我们期待的到是格式是包含code和name的键值对的形式，而不是以上的形式。通过在Common接口中添加以上方法可以实现：123456@JsonValuedefault Map&lt;C, N&gt; toMap() &#123; Map&lt;C, N&gt; map = new HashMap&lt;&gt;(1); map.put(getCode(), getName()); return map;&#125; 此时再次通过页面请求，得到的结果将如下：12345678910111213141516171819202122232425262728293031323334353637&#123; \"code\": 0, \"success\": true, \"data\": &#123; \"blogStatus\": [ &#123; \"1\": \"自己可见\" &#125;, &#123; \"2\": \"好友可见\" &#125;, &#123; \"3\": \"登陆用户可见\" &#125;, &#123; \"4\": \"公开\" &#125; ], \"blogType\": [ &#123; \"1\": \"原创博文\" &#125;, &#123; \"2\": \"转载文章\" &#125;, &#123; \"3\": \"问答\" &#125;, &#123; \"4\": \"投票\" &#125;, &#123; \"5\": \"专栏\" &#125; ] &#125;&#125; 此外，如果想通过使用fastjson的JSON.toJSONString()也能得到如上格式的结果，可以让Common继承com.alibaba.fastjson.JSONAware,并在Common中实现JSONAware的toJSONString方法:1234@Overridedefault String toJSONString() &#123; return JSON.toJSONString(toMap());&#125; 以下代码将会通过:1Assert.assertEquals(\"&#123;2:\\\"转载文章\\\"&#125;\", JSON.toJSONString(BlogType.REPRINT)); 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONAware;import com.fasterxml.jackson.annotation.JsonValue;import java.util.Arrays;import java.util.HashMap;import java.util.Map;/** * @author wf2311 */public interface Enums &#123; interface Common&lt;C, N&gt; extends JSONAware &#123; C getCode(); N getName(); static &lt;E extends Enum&lt;E&gt; &amp; Common, C&gt; E getByCode(Class&lt;E&gt; clazz, C code) &#123; return Arrays.stream(clazz.getEnumConstants()) .filter(t -&gt; t.getCode().equals(code)) .findFirst().orElse(null); &#125; @JsonValue default Map&lt;C, N&gt; toMap() &#123; Map&lt;C, N&gt; map = new HashMap&lt;&gt;(1); map.put(getCode(), getName()); return map; &#125; @Override default String toJSONString() &#123; return JSON.toJSONString(toMap()); &#125; &#125; enum BlogType implements Common &#123; BLOG(1, \"原创博文\"), REPRINT(2, \"转载文章\"), QUESTION(3, \"问答\"), VOTE(4, \"投票\"), SUBJECT(5, \"专栏\"); private Integer code; private String name; BlogType(Integer code, String name) &#123; this.code = code; this.name = name; &#125; public Integer getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125; &#125; enum BlogStatus implements Common &#123; PRIVATE(1, \"自己可见\"), FRIEND(2, \"好友可见\"), ONLINE(3, \"登陆用户可见\"), PUBLISH(4, \"公开\"); private int code; private String name; BlogStatus(Integer code, String name) &#123; this.code = code; this.name = name; &#125; public Integer getCode() &#123; return code; &#125; public String getName() &#123; return name; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wangfeng.pro/categories/Java/"}],"tags":[{"name":"enum","slug":"enum","permalink":"https://wangfeng.pro/tags/enum/"},{"name":"json","slug":"json","permalink":"https://wangfeng.pro/tags/json/"}]},{"title":"Maven常用命令","slug":"Maven常用命令","date":"2017-07-28T08:49:07.000Z","updated":"2018-01-12T12:08:31.391Z","comments":true,"path":"a/Maven常用命令/","link":"","permalink":"https://wangfeng.pro/a/Maven常用命令/","excerpt":"","text":"更新父模块到指定版本号 1mvn versions:set -DnewVersion=1.0.1-SNAPSHOT 更新子模块版本到与模块相同 1mvn -N versions:update-child-modules 发布版本到指定本地仓库 1mvn deploy -DskipTests -DaltDeploymentRepository=wf2311-mvn-repo::default::file:D:/Projects/open-source/maven-repo/repository/ 跳过测试 1-DskipTests 跳过gpg签名 1-DskipGPG 查看执行过程 1-X 把jar包加入本地仓库 1mvn install:install-file -Dfile=D:\\thrift-0.9.2.jar -DgroupId=org.apache.thrift -DartifactId=libthrift -Dversion=0.9.2 -Dpackaging=jar","categories":[{"name":"其它","slug":"其它","permalink":"https://wangfeng.pro/categories/其它/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://wangfeng.pro/tags/maven/"}]},{"title":"SpringBoot中使用thymeleaf模板在找不到对于模板的解决方法","slug":"SpringBoot中使用thymeleaf模板在找不到对于模板的解决方法","date":"2017-07-28T03:04:21.000Z","updated":"2018-01-12T12:08:31.390Z","comments":true,"path":"a/SpringBoot中使用thymeleaf模板在找不到对于模板的解决方法/","link":"","permalink":"https://wangfeng.pro/a/SpringBoot中使用thymeleaf模板在找不到对于模板的解决方法/","excerpt":"","text":"问题描述SpringBoot中使用thymeleaf模板，在IDEA中以main方法运行可以正常显示页面，但在打包之后就会提示找不到模板页面的错误信息:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[THYMELEAF][http-nio-4000-exec-1] Exception processing template \"/blog/index\": Error resolving template \"/blog/index\", template might not exist or might not be accessible by any of the configured Template Resolversorg.thymeleaf.exceptions.TemplateInputException: Error resolving template \"/blog/index\", template might not exist or might not be accessible by any of the configured Template Resolvers at org.thymeleaf.engine.TemplateManager.resolveTemplate(TemplateManager.java:870) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:607) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.renderFragment(ThymeleafView.java:353) [thymeleaf-spring4-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.render(ThymeleafView.java:191) [thymeleaf-spring4-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1286) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1041) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:984) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) [tomcat-embed-websocket-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter.doFilter(ResourceUrlEncodingFilter.java:59) [spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_74] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_74] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at java.lang.Thread.run(Thread.java:745) [?:1.8.0_74]Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: Error resolving template \"/blog/index\", template might not exist or might not be accessible by any of the configured Template Resolvers] with root causeorg.thymeleaf.exceptions.TemplateInputException: Error resolving template \"/blog/index\", template might not exist or might not be accessible by any of the configured Template Resolvers at org.thymeleaf.engine.TemplateManager.resolveTemplate(TemplateManager.java:870) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:607) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.renderFragment(ThymeleafView.java:353) ~[thymeleaf-spring4-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.thymeleaf.spring4.view.ThymeleafView.render(ThymeleafView.java:191) ~[thymeleaf-spring4-3.0.7.RELEASE.jar!/:3.0.7.RELEASE] at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1286) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1041) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:984) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) ~[tomcat-embed-websocket-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter.doFilter(ResourceUrlEncodingFilter.java:59) ~[spring-webmvc-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-4.3.10.RELEASE.jar!/:4.3.10.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_74] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_74] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-8.5.16.jar!/:8.5.16] at java.lang.Thread.run(Thread.java:745) [?:1.8.0_74] 错误原因参考stackflow 类似的问题 You don’t need the leading / on the view name, i.e. you should return fragments :: nodeList rather than /fragments :: nodeList. Having made this change Thymeleaf should be able to find the template when run from your IDE or from a jar file.If you’re interested, here’s what’s happening under the hood:The view name is used to search for a resource on the classpath. fragments :: nodeList means that the resource name is /templates/fragments.html and /fragments :: nodeList means that the resource name is /templates//fragments.html (note the double slash). When you’re running in your IDE the resource is available straight off the filesystem and the double slash doesn’t cause a problem. When you’re running from a jar file the resource is nested within that jar and the double slash prevents it from being found. I don’t fully understand why there’s this difference in behaviour and it is rather unfortunate. I’ve opened an issue so that we (the Spring Boot team) can see if there’s anything we can do to make the behaviour consistent. 简单来说就是在springboot配置文件里的spring.thymeleaf.prefix=classpath:/templates/的与返回页面的视图设置mav.setViewName(&quot;/blog/write&quot;); 在组成url路径时会构成一个双斜杠//，在IDEA中运行时是可以被识别的，但在程序打包运行之后就不能被识别了，所以会出现这个问题。 解决办法根据上面的错误原因分析，目前的解决办法就是让模板的路径中不会出现双斜杠//，或者支持双斜杠//路径(目前已经有人在jira中提出了该bug 期待在之后的版本中能狗支持双斜杠//路径) 去掉返回视图页面最前面的斜杠： mav.setViewName(&quot;/blog/write&quot;); 改为 mav.setViewName(&quot;blog/write&quot;); 或者在配置文件里去掉最后的斜杠： spring.thymeleaf.prefix=classpath:/templates/ 改为 spring.thymeleaf.prefix=classpath:/templates 同时需要修改thymeleaf模板文件中的相关内容，比如 layout:decorate=&quot;~{blog/common/common} 此时应变为 layout:decorate=&quot;~{/blog/common/common}","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wangfeng.pro/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wangfeng.pro/tags/SpringBoot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://wangfeng.pro/tags/thymeleaf/"}]},{"title":"Java NIO源码分析之Buffer","slug":"Java NIO源码分析之Buffer","date":"2017-07-20T11:19:19.000Z","updated":"2018-01-12T12:08:31.390Z","comments":true,"path":"a/Java NIO源码分析之Buffer/","link":"","permalink":"https://wangfeng.pro/a/Java NIO源码分析之Buffer/","excerpt":"","text":"Buffer是特定基元类型数据的容器Buffer(缓冲区)是一种特定基元类型的线性、有限序列。除了内容之外，缓冲区的基本属性是capacity(容量)、limit(上限)和position(位置)以及mark(标记): capacity 缓冲区能够容纳的数据元素的最大数量。这一容量在缓冲区创建时被设定，并且永远不能被改变。limit 缓冲区的第一个不能被读或写的元素。或者说，缓冲区中现存元素的计数。position 下一个要被读或写的元素的索引。位置会自动由相应的get()和put()函数更新。mark 一个备忘位置。调用mark()来设定mark = postion。调用reset()设定position = mark。标记在设定前是未定义的(undefined)。这四个属性之间总是遵循以下关系：10 &lt;= mark &lt;= position &lt;= limit &lt;= capacity","categories":[{"name":"Java","slug":"Java","permalink":"https://wangfeng.pro/categories/Java/"}],"tags":[{"name":"nio","slug":"nio","permalink":"https://wangfeng.pro/tags/nio/"}]},{"title":"Git常用操作命令","slug":"Git常用操作命令","date":"2017-07-19T09:24:22.000Z","updated":"2018-01-12T12:08:31.389Z","comments":true,"path":"a/Git常用操作命令/","link":"","permalink":"https://wangfeng.pro/a/Git常用操作命令/","excerpt":"","text":"克隆远程制定分支到本地1git clone -b &lt;branch&gt; &lt;remote_repo&gt; ## branch为分支名，remote_repo为远程仓库 标签相关切换到指定分支1git checkout &lt;branch&gt; 检出指定分支1git checkout tags/&lt;tag_name&gt; -b &lt;branch_name&gt; 新建标签1git tag &lt;tagName&gt; 查看所有标签1git tag","categories":[{"name":"其它","slug":"其它","permalink":"https://wangfeng.pro/categories/其它/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wangfeng.pro/tags/git/"},{"name":"常用命令","slug":"常用命令","permalink":"https://wangfeng.pro/tags/常用命令/"}]},{"title":"HttpServletRequest常用获取URL的方法","slug":"HttpServletRequest常用获取URL的方法","date":"2017-07-17T02:56:50.000Z","updated":"2018-01-12T12:08:31.389Z","comments":true,"path":"a/HttpServletRequest常用获取URL的方法/","link":"","permalink":"https://wangfeng.pro/a/HttpServletRequest常用获取URL的方法/","excerpt":"","text":"1、request.getRequestURL()返回的是完整的url，包括Http协议，端口号，servlet名字和映射路径，但它不包含请求参数。2、request.getRequestURI()得到的是request URL的部分值，并且web容器没有decode过的3、request.getContextPath()返回 the context of the request.4、request.getServletPath()返回调用servlet的部分url.5、request.getQueryString()返回url路径后面的查询字符串 示例： 当前url：http://localhost:8080/CarsiLogCenter_new/idpstat.jsp?action=idp.sptopn request.getRequestURL() http://localhost:8080/CarsiLogCenter_new/idpstat.jsp request.getRequestURI() /CarsiLogCenter_new/idpstat.jsp request.getContextPath()/CarsiLogCenter_new request.getServletPath() /idpstat.jsp request.getQueryString()action=idp.sptopn","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://wangfeng.pro/categories/Java-Web/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://wangfeng.pro/tags/Servlet/"},{"name":"HttpServletRequest","slug":"HttpServletRequest","permalink":"https://wangfeng.pro/tags/HttpServletRequest/"},{"name":"SpringMvc","slug":"SpringMvc","permalink":"https://wangfeng.pro/tags/SpringMvc/"}]},{"title":"使用thymeleaf变量给onclick属性赋值","slug":"使用thymeleaf变量给onclick属性赋值","date":"2017-07-15T01:47:13.000Z","updated":"2018-01-12T12:08:31.389Z","comments":true,"path":"a/使用thymeleaf变量给onclick属性赋值/","link":"","permalink":"https://wangfeng.pro/a/使用thymeleaf变量给onclick属性赋值/","excerpt":"","text":"在使用thymeleaf渲染页面时，遇到如下情况：1&lt;button onclick=\"submit('publish');\"&gt;提交&lt;/button&gt; submit函数的参数会根据后端参数的不同而动态改变，Google搜索到了一些类似问题，记录一下解决方法。 已经测试可用的：1th:onclick=\"'alert(\\'' + $&#123;myVar&#125; + '\\');'\" 还未测试：12345&lt;button th:onclick=\"'javascript:upload(' + $&#123;gallery&#125; + ')'\"&gt;&lt;/button&gt;th:onclick=\"|upload('$&#123;command['class'].simpleName&#125;', '$&#123;gallery&#125;')|\"&lt;div th:style=\"'background:url(' + @&#123;/&lt;path-to-image&gt;&#125; + ');'\"&gt;&lt;/div&gt;","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://wangfeng.pro/categories/Java-Web/"}],"tags":[{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://wangfeng.pro/tags/thymeleaf/"}]},{"title":"MySQL 优化之 index merge(索引合并)","slug":"MySQL 优化之 index merge(索引合并)","date":"2017-07-14T08:09:10.000Z","updated":"2018-01-12T12:08:31.388Z","comments":true,"path":"a/MySQL 优化之 index merge(索引合并)/","link":"","permalink":"https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/","excerpt":"","text":"深入理解 index merge 是使用索引进行优化的重要基础之一。理解了 index merge 技术，我们才知道应该如何在表上建立索引。 1. 为什么会有index merge我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。 MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描。 相关文档：http://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html (注意该文档中说的有几处错误) The Index Merge method is used to retrieve rows with several range scans and to merge their results into one. The merge can produce unions, intersections, or unions-of-intersections of its underlying scans. This access method merges index scans from a single table; it does not merge scans across multiple tables. In EXPLAIN output, the Index Merge method appears as index_merge in the type column. In this case, the key column contains a list of indexes used, and key_len contains a list of the longest key parts for those indexes. index merge: 同一个表的多个索引的范围扫描可以对结果进行合并，合并方式分为三种：union, intersection, 以及它们的组合(先内部intersect然后在外面union)。 官方文档给出了四个例子：1234SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;SELECT * FROM tbl_name WHERE (key1 = 10 OR key2 = 20) AND non_key=30;SELECT * FROM t1, t2 WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%') AND t2.key1=t1.some_col;SELECT * FROM t1, t2 WHERE t1.key1=1 AND (t2.key1=t1.some_col OR t2.key2=t1.some_col2); 但是第四个例子，感觉并不会使用 index merge. 因为 t2.key1=t1.some_col 和 t2.key2=t1.some_col2 之间进行的是 OR 运算，而且 t2.key2 是复合索引的第二个字段(非第一个字段)。所以：t2.key2 = t1.some_col2 并不能使用到复合索引。(文档这里应该是错误的) index merge 算法根据合并算法的不同分成了三种：intersect, union, sort_union. 2. index merge 之 intersect简单而言，index intersect merge就是多个索引条件扫描得到的结果进行交集运算。显然在多个索引提交之间是 AND 运算时，才会出现 index intersect merge. 下面两种where条件或者它们的组合时会进行 index intersect merge: 1) 条件使用到复合索引中的所有字段或者左前缀字段(对单字段索引也适用) key_part1=const1 AND key_part2=const2 … AND key_partN=constN2) 主键上的任何范围条件 例子： 12SELECT * FROM innodb_table WHERE primary_key &lt; 10 AND key_col1=20;SELECT * FROM tbl_name WHERE (key1_part1=1 AND key1_part2=2) AND key2=2; 上面只说到复合索引，但是其实单字段索引显然也是一样的。比如 select * from tab where key1=xx and key2 =xxx; 也是有可能进行index intersect merge的。另外上面两种情况的 AND 组合也一样可能会进行 index intersect merge. The Index Merge intersection algorithm performs simultaneous scans on all used indexes and produces the intersection of row sequences that it receives from the merged index scans. (intersect merge运行方式：多个索引同时扫描，然后结果取交集) If all columns used in the query are covered by the used indexes, full table rows are not retrieved (EXPLAIN output contains Using index in Extra field in this case). Here is an example of such a query:(索引覆盖扫描，无需回表) 1SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1; If the used indexes do not cover all columns used in the query, full rows are retrieved only when the range conditions for all used keys are satisfied.(索引不能覆盖，则对满足条件的再进行回表) If one of the merged conditions is a condition over a primary key of an InnoDB table, it is not used for row retrieval, but is used to filter out rows retrieved using other conditions. 3. index merge 之 union简单而言，index uion merge就是多个索引条件扫描，对得到的结果进行并集运算，显然是多个条件之间进行的是 OR 运算。 下面几种类型的 where 条件，以及他们的组合可能会使用到 index union merge算法： 1) 条件使用到复合索引中的所有字段或者左前缀字段(对单字段索引也适用) 2) 主键上的任何范围条件 3) 任何符合 index intersect merge 的where条件； 上面三种 where 条件进行 OR 运算时，可能会使用 index union merge算法。 例子： SELECT FROM t1 WHERE key1=1 OR key2=2 OR key3=3;SELECT FROM innodb_table WHERE (key1=1 AND key2=2) OR (key3=’foo’ AND key4=’bar’) AND key5=5;第一个例子，就是三个 单字段索引 进行 OR 运算，所以他们可能会使用 index union merge算法。 第二个例子，复杂一点。(key1=1 AND key2=2) 是符合 index intersect merge; (key3=’foo’ AND key4=’bar’) AND key5=5 也是符合index intersect merge，所以 二者之间进行 OR 运算，自然可能会使用 index union merge算法。 4. index merge 之 sort_unionThis access algorithm is employed when the WHERE clause was converted to several range conditions combined by OR, but for which the Index Merge method union algorithm is not applicable.(多个条件扫描进行 OR 运算，但是不符合 index union merge算法的，此时可能会使用 sort_union算法) 官方文档给出了两个例子： SELECT FROM tbl_name WHERE key_col1 &lt; 10 OR key_col2 &lt; 20;SELECT FROM tbl_name WHERE (key_col1 &gt; 10 OR key_col2 = 20) AND nonkey_col=30;但是显然：因为 key_col2 不是复合索引的第一个字段，对它进行 OR 运算，是不可能使用到索引的。所以这两个例子应该也是错误的，它们实际上并不会进行 index sort_union merge算法。 The difference between the sort-union algorithm and the union algorithm is that the sort-union algorithm must first fetch row IDs for all rows and sort them before returning any rows.(sort-union合并算法和union合并算法的不同点，在于返回结果之前是否排序，为什么需要排序呢？可能是因为两个结果集，进行并集运算，需要去重，所以才进行排序？？？) 5. index merge的局限1）If your query has a complex WHERE clause with deep AND/OR nesting and MySQL does not choose the optimal plan, try distributing terms using the following identity laws: (x AND y) OR z = (x OR z) AND (y OR z)(x OR y) AND z = (x AND z) OR (y AND z)如果我们的条件比较复杂，用到多个 and / or 条件运算，而MySQL没有使用最优的执行计划，那么可以使用上面的两个等式将条件进行转换一下。 2）Index Merge is not applicable to full-text indexes. We plan to extend it to cover these in a future MySQL release.(全文索引没有index merge) 3）Before MySQL 5.6.6, if a range scan is possible on some key, the optimizer will not consider using Index Merge Union or Index Merge Sort-Union algorithms. For example, consider this query: SELECT * FROM t1 WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND badkey &lt; 30;For this query, two plans are possible: An Index Merge scan using the (goodkey1 &lt; 10 OR goodkey2 &lt; 20) condition. A range scan using the badkey &lt; 30 condition. However, the optimizer considers only the second plan. 这一点对以低版本的MySQL是一个很大的缺陷。就是如果where条件中有 &gt;, &lt;, &gt;=, &lt;=等条件，那么优化器不会使用 index merge，而且还会忽略其他的索引，不会使用它们，哪怕他们的选择性更优。 6. 对 index merge 的进一步优化index merge使得我们可以使用到多个索引同时进行扫描，然后将结果进行合并。听起来好像是很好的功能，但是如果出现了 index intersect merge，那么一般同时也意味着我们的索引建立得不太合理，因为 index intersect merge 是可以通过建立 复合索引进行更一步优化的。 比如下面的select: SELECT * FROM t1 WHERE key1=1 AND key2=2 AND key3=3;显然我们是可以在这三个字段上建立一个复合索引来进行优化的，这样就只需要扫描一个索引一次，而不是对三个所以分别扫描一次。 percona官网有一篇 比较复合索引和index merge 的好文章：Multi Column indexes vs Index Merge 7. 复合索引的最左前缀原则上面我们说到，对复合索引的非最左前缀字段进行 OR 运算，是无法使用到复合索引的。比如： SELECT * FROM tbl_name WHERE (key_col1 &gt; 10 OR key_col2 = 20) AND nonkey_col=30;其原因是，MySQL中的索引，使用的是B+tree, 也就是说他是：先按照复合索引的 第一个字段的大小来排序，插入到 B+tree 中的，当第一个字段值相同时，在按照第二个字段的值比较来插入的。那么如果我们需要对： OR key_col2 = 20 这样的条件也使用复合索引，那么该怎么操作呢？应该要对复合索引进行全扫描，找出所有 key_col2 =20 的项，然后还要回表去判断 nonkey_col=30，显然代价太大了。所以一般而言 OR key_col2 = 20 这样的条件是无法使用到复合索引的。如果一定要使用索引，那么可以在 col2 上单独建立一个索引。 复合索引的最左前缀原则： MySQL中的复合索引，查询时只会使用到最左前缀，比如：1234567891011121314 mysql&gt; show index from role_goods; +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ | role_goods | 0 | PRIMARY | 1 | id | A | 22816 | NULL | NULL | | BTREE | | | | role_goods | 1 | roleId | 1 | roleId | A | 1521 | NULL | NULL | YES | BTREE | | | | role_goods | 1 | goodsId | 1 | goodsId | A | 1521 | NULL | NULL | YES | BTREE | | | | role_goods | 1 | roleId_2 | 1 | roleId | A | 1901 | NULL | NULL | YES | BTREE | | | | role_goods | 1 | roleId_2 | 2 | status | A | 4563 | NULL | NULL | YES | BTREE | | | | role_goods | 1 | roleId_2 | 3 | number | A | 22816 | NULL | NULL | YES | BTREE | | | +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+6 rows in set (0.00 sec) 上面有一个复合索引：roleId_2(roleId,status,number)，如果条件是： where roleId=xxx and number=xxx，那么此时只会使用到最左前缀roleId，而不会使用到 number 来进行过滤。因为它们中间存在一个字段 status 没有出现在where条件中。实验如下所示： 123456789101112131415161718192021222324252627282930mysql&gt; explain select * from role_goods where roleId=100000001 and status=1 and number=1 limit 1;+----+-------------+------------+------+-----------------+----------+---------+-------------------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+------+-----------------+----------+---------+-------------------+------+-------+| 1 | SIMPLE | role_goods | ref | roleId,roleId_2 | roleId_2 | 23 | const,const,const | 13 | NULL |+----+-------------+------------+------+-----------------+----------+---------+-------------------+------+-------+1 row in set (0.00 sec)mysql&gt; explain select * from role_goods where roleId=100000001 and status=1 limit 1;+----+-------------+------------+------+-----------------+----------+---------+-------------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+------+-----------------+----------+---------+-------------+------+-------+| 1 | SIMPLE | role_goods | ref | roleId,roleId_2 | roleId_2 | 14 | const,const | 13 | NULL |+----+-------------+------------+------+-----------------+----------+---------+-------------+------+-------+1 row in set (0.00 sec)mysql&gt; explain select * from role_goods where roleId=100000001 and number=1 limit 1;+----+-------------+------------+------+-----------------+--------+---------+-------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+------+-----------------+--------+---------+-------+------+-------------+| 1 | SIMPLE | role_goods | ref | roleId,roleId_2 | roleId | 9 | const | 14 | Using where |+----+-------------+------------+------+-----------------+--------+---------+-------+------+-------------+1 row in set (0.01 sec)mysql&gt; explain select * from role_goods ignore index(roleId) where roleId=100000001 and number=1 limit 1;+----+-------------+------------+------+---------------+----------+---------+-------+------+-----------------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+------------+------+---------------+----------+---------+-------+------+-----------------------+| 1 | SIMPLE | role_goods | ref | roleId_2 | roleId_2 | 9 | const | 14 | Using index condition |+----+-------------+------------+------+---------------+----------+---------+-------+------+-----------------------+1 row in set (0.01 sec) 可以看到 key_len 的变化： 显然最后一个查询仅仅使用到符合索引中的 roleId, 没有使用到 number. number使用在了 index conditon(也就是索引的push down技术) 注意最左前缀，并不是是指：一定要按照各个字段出现在where中的顺序来建立复合索引的。比如1where status=2 and roleId=xxx and number = xxx 该条件建立符合索引，我们并不需要按照status,roleId，number它们出现的顺序来建立索引：1alter table role_goods add index sin(status,roleId,number) 这是对最左前缀极大的误解。因为 where status=2 and roleId=xxx and number = xxx 和 where roleId=xxx and number = xxx and status=2它们是等价的。复合索引，哪个字段放在最前面，需要根据哪个字段经常出现在where条件中，哪个字段的选择性最好来判断的。 进一步可以参考的文章： http://www.orczhou.com/index.php/2013/01/mysql-source-code-query-optimization-index-merge/ http://www.cnblogs.com/nocode/archive/2013/01/28/2880654.html","categories":[{"name":"数据库","slug":"数据库","permalink":"https://wangfeng.pro/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://wangfeng.pro/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"https://wangfeng.pro/tags/索引/"}]},{"title":"微信web协议分析和实现微信机器人","slug":"微信web协议分析和实现微信机器人","date":"2017-07-14T08:01:19.000Z","updated":"2018-01-12T12:08:31.384Z","comments":true,"path":"a/微信web协议分析和实现微信机器人/","link":"","permalink":"https://wangfeng.pro/a/微信web协议分析和实现微信机器人/","excerpt":"","text":"微信web协议分析和实现微信机器人（微信网页版 wx2.qq.com）时间: 2017-05-22 14:16:34 1.打开首页，分配一个随机uuid，2.根据该uuid获取二维码图片。3.微信客户端扫描该图片，在客户端确认登录。4.浏览器不停的调用一个接口，如果返回登录成功，则调用登录接口5.此时可以获取联系人列表，可以发送消息。然后不断调用同步接口。6.如果同步接口有返回，则可以获取新消息，然后继续调用同步接口。 Java版实现源码：https://github.com/biezhi/wechat-robot Python实现：https://github.com/Urinx/WeixinBot C#实现：https://github.com/sherlockchou86/WeChat.NET QT实现：https://github.com/xiangzhai/qwx Perl实现：https://github.com/sjdy521/Mojo-Weixin 执行流程123456789101112131415161718192021222324 +--------------+ +---------------+ +---------------+ | | | | | | | Get UUID | | Get Contact | | Status Notify | | | | | | | +-------+------+ +-------^-------+ +-------^-------+ | | | | +-------+ +--------+ | | | +-------v------+ +-----+--+------+ +--------------+ | | | | | | | Get QRCode | | Weixin Init +------&gt; Sync Check &lt;----+ | | | | | | | +-------+------+ +-------^-------+ +-------+------+ | | | | | | | +-----------+ | | | +-------v------+ +-------+--------+ +-------v-------+ | | Confirm Login | | | |+------&gt; Login +---------------&gt; New Login Page | | Weixin Sync || | | | | | || +------+-------+ +----------------+ +---------------+| ||QRCode Scaned|+-------------+ WebWechat API1. 获取UUID（参考方法 getUUID） API 获取 UUID url https://login.weixin.qq.com/jslogin method GET data URL Encode params appid : wx782c26e4c19acffb fun : new lang: zh_CN _ : 时间戳 返回数据(String): 1window.QRLogin.code = 200; window.QRLogin.uuid = &quot;xxx&quot; 2. 显示二维码（参考方法 showQrCode） API 显示二维码 url https://login.weixin.qq.com/qrcode/{uuid} method POST params t : webwx _ : 时间戳 3. 等待登录（参考方法 waitForLogin）这里是微信确认登录 API 二维码扫描登录 url https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login method GET params tip : 1:未扫描 0:已扫描 uuid : 获取到的uuid _ : 时间戳 返回数据(String):123456789window.code=xxx;xxx: 408 登陆超时 201 扫描成功 200 确认登录当返回200时，还会有window.redirect_uri=&quot;https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxnewloginpage?ticket=xxx&amp;uuid=xxx&amp;lang=xxx&amp;scan=xxx&quot;; 4. 登录获取Cookie（参考方法 login） API webwxnewloginpage url https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxnewloginpage method GET params ticket : xxx uuid : xxx lang : zh_CN scan : xxx fun : new 返回数据(XML):123456789&lt;error&gt; &lt;ret&gt;0&lt;/ret&gt; &lt;message&gt;OK&lt;/message&gt; &lt;skey&gt;xxx&lt;/skey&gt; &lt;wxsid&gt;xxx&lt;/wxsid&gt; &lt;wxuin&gt;xxx&lt;/wxuin&gt; &lt;pass_ticket&gt;xxx&lt;/pass_ticket&gt; &lt;isgrayscale&gt;1&lt;/isgrayscale&gt;&lt;/error&gt; 在这一步获取xml中的 skey, wxsid, wxuin, pass_ticket 5. 微信初始化（参考方法 wxInit） API webwxinit url https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxinit method POST data JSON header Content-Type: application/json; charset=UTF-8 params { &nbsp;&nbsp;&nbsp;&nbsp; BaseRequest: { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uin: xxx, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sid: xxx, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Skey: xxx, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceID: xxx, &nbsp;&nbsp;&nbsp;&nbsp; } } 返回数据(JSON):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; &quot;BaseResponse&quot;: &#123; &quot;Ret&quot;: 0, &quot;ErrMsg&quot;: &quot;&quot; &#125;, &quot;Count&quot;: 11, &quot;ContactList&quot;: [...], &quot;SyncKey&quot;: &#123; &quot;Count&quot;: 4, &quot;List&quot;: [ &#123; &quot;Key&quot;: 1, &quot;Val&quot;: 635705559 &#125;, ... ] &#125;, &quot;User&quot;: &#123; &quot;Uin&quot;: xxx, &quot;UserName&quot;: xxx, &quot;NickName&quot;: xxx, &quot;HeadImgUrl&quot;: xxx, &quot;RemarkName&quot;: &quot;&quot;, &quot;PYInitial&quot;: &quot;&quot;, &quot;PYQuanPin&quot;: &quot;&quot;, &quot;RemarkPYInitial&quot;: &quot;&quot;, &quot;RemarkPYQuanPin&quot;: &quot;&quot;, &quot;HideInputBarFlag&quot;: 0, &quot;StarFriend&quot;: 0, &quot;Sex&quot;: 1, &quot;Signature&quot;: &quot;Apt-get install B&quot;, &quot;AppAccountFlag&quot;: 0, &quot;VerifyFlag&quot;: 0, &quot;ContactFlag&quot;: 0, &quot;WebWxPluginSwitch&quot;: 0, &quot;HeadImgFlag&quot;: 1, &quot;SnsFlag&quot;: 17 &#125;, &quot;ChatSet&quot;: xxx, &quot;SKey&quot;: xxx, &quot;ClientVersion&quot;: 369297683, &quot;SystemTime&quot;: 1453124908, &quot;GrayScale&quot;: 1, &quot;InviteStartCount&quot;: 40, &quot;MPSubscribeMsgCount&quot;: 2, &quot;MPSubscribeMsgList&quot;: [...], &quot;ClickReportInterval&quot;: 600000&#125; 这一步中获取 SyncKey, User 后面的消息监听用。 6. 开启微信状态通知（参考方法 wxStatusNotify） API webwxstatusnotify url https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxstatusnotify method POST data JSON header Content-Type: application/json; charset=UTF-8 params { &nbsp;&nbsp;&nbsp;&nbsp; BaseRequest: { Uin: xxx, Sid: xxx, Skey: xxx, DeviceID: xxx }, &nbsp;&nbsp;&nbsp;&nbsp; Code: 3, &nbsp;&nbsp;&nbsp;&nbsp; FromUserName: 自己的ID, &nbsp;&nbsp;&nbsp;&nbsp; ToUserName: 自己的ID, &nbsp;&nbsp;&nbsp;&nbsp; ClientMsgId: 时间戳 } 返回数据(JSON):1234567&#123; &quot;BaseResponse&quot;: &#123; &quot;Ret&quot;: 0, &quot;ErrMsg&quot;: &quot;&quot; &#125;, ...&#125; 7. 获取联系人列表（参考方法 getContact） API webwxgetcontact url https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxgetcontact method POST data JSON header ContentType: application/json; charset=UTF-8 params { &nbsp;&nbsp;&nbsp;&nbsp; BaseRequest: { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uin: xxx, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sid: xxx, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Skey: xxx, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceID: xxx, &nbsp;&nbsp;&nbsp;&nbsp; } } 返回数据(JSON):12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &quot;BaseResponse&quot;: &#123; &quot;Ret&quot;: 0, &quot;ErrMsg&quot;: &quot;&quot; &#125;, &quot;MemberCount&quot;: 334, &quot;MemberList&quot;: [ &#123; &quot;Uin&quot;: 0, &quot;UserName&quot;: xxx, &quot;NickName&quot;: &quot;Urinx&quot;, &quot;HeadImgUrl&quot;: xxx, &quot;ContactFlag&quot;: 3, &quot;MemberCount&quot;: 0, &quot;MemberList&quot;: [], &quot;RemarkName&quot;: &quot;&quot;, &quot;HideInputBarFlag&quot;: 0, &quot;Sex&quot;: 0, &quot;Signature&quot;: &quot;我是二蛋&quot;, &quot;VerifyFlag&quot;: 8, &quot;OwnerUin&quot;: 0, &quot;PYInitial&quot;: &quot;URINX&quot;, &quot;PYQuanPin&quot;: &quot;Urinx&quot;, &quot;RemarkPYInitial&quot;: &quot;&quot;, &quot;RemarkPYQuanPin&quot;: &quot;&quot;, &quot;StarFriend&quot;: 0, &quot;AppAccountFlag&quot;: 0, &quot;Statues&quot;: 0, &quot;AttrStatus&quot;: 0, &quot;Province&quot;: &quot;&quot;, &quot;City&quot;: &quot;&quot;, &quot;Alias&quot;: &quot;Urinxs&quot;, &quot;SnsFlag&quot;: 0, &quot;UniFriend&quot;: 0, &quot;DisplayName&quot;: &quot;&quot;, &quot;ChatRoomId&quot;: 0, &quot;KeyWord&quot;: &quot;gh_&quot;, &quot;EncryChatRoomId&quot;: &quot;&quot; &#125;, ... ], &quot;Seq&quot;: 0&#125; 8.消息检查（参考方法 syncCheck） API synccheck url https://webpush2.weixin.qq.com/cgi-bin/mmwebwx-bin/synccheck method GET data JSON header ContentType: application/json; charset=UTF-8 params { &nbsp;&nbsp;&nbsp;&nbsp; BaseRequest: { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uin: xxx, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sid: xxx, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Skey: xxx, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeviceID: xxx, &nbsp;&nbsp;&nbsp;&nbsp; } } 返回数据(String):123456789window.synccheck=&#123;retcode:&quot;xxx&quot;,selector:&quot;xxx&quot;&#125;retcode: 0 正常 1100 失败/登出微信selector: 0 正常 2 新的消息 7 进入/离开聊天界面 9. 获取最新消息（参考方法 webwxsync） API webwxsync url https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxsync?sid=xxx&amp;skey=xxx&amp;pass_ticket=xxx method POST data JSON header ContentType: application/json; charset=UTF-8 params { &nbsp;&nbsp;&nbsp;&nbsp; BaseRequest: { Uin: xxx, Sid: xxx, Skey: xxx, DeviceID: xxx }, &nbsp;&nbsp;&nbsp;&nbsp; SyncKey: xxx, &nbsp;&nbsp;&nbsp;&nbsp; rr: 时间戳取反 } 返回数据(JSON):12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; &apos;BaseResponse&apos;: &#123;&apos;ErrMsg&apos;: &apos;&apos;, &apos;Ret&apos;: 0&#125;, &apos;SyncKey&apos;: &#123; &apos;Count&apos;: 7, &apos;List&apos;: [ &#123;&apos;Val&apos;: 636214192, &apos;Key&apos;: 1&#125;, ... ] &#125;, &apos;ContinueFlag&apos;: 0, &apos;AddMsgCount&apos;: 1, &apos;AddMsgList&apos;: [ &#123; &apos;FromUserName&apos;: &apos;&apos;, &apos;PlayLength&apos;: 0, &apos;RecommendInfo&apos;: &#123;...&#125;, &apos;Content&apos;: &quot;&quot;, &apos;StatusNotifyUserName&apos;: &apos;&apos;, &apos;StatusNotifyCode&apos;: 5, &apos;Status&apos;: 3, &apos;VoiceLength&apos;: 0, &apos;ToUserName&apos;: &apos;&apos;, &apos;ForwardFlag&apos;: 0, &apos;AppMsgType&apos;: 0, &apos;AppInfo&apos;: &#123;&apos;Type&apos;: 0, &apos;AppID&apos;: &apos;&apos;&#125;, &apos;Url&apos;: &apos;&apos;, &apos;ImgStatus&apos;: 1, &apos;MsgType&apos;: 51, &apos;ImgHeight&apos;: 0, &apos;MediaId&apos;: &apos;&apos;, &apos;FileName&apos;: &apos;&apos;, &apos;FileSize&apos;: &apos;&apos;, ... &#125;, ... ], &apos;ModChatRoomMemberCount&apos;: 0, &apos;ModContactList&apos;: [], &apos;DelContactList&apos;: [], &apos;ModChatRoomMemberList&apos;: [], &apos;DelContactCount&apos;: 0, ...&#125; 10. 发送消息（参考方法 webwxsendmsg） API webwxsendmsg url https://wx2.qq.com/cgi-bin/mmwebwx-bin/webwxsendmsg?pass_ticket=xxx method POST data JSON header ContentType: application/json; charset=UTF-8 params { &nbsp;&nbsp;&nbsp;&nbsp; BaseRequest: { Uin: xxx, Sid: xxx, Skey: xxx, DeviceID: xxx }, &nbsp;&nbsp;&nbsp;&nbsp; Msg: { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type: 1 文字消息, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Content: 要发送的消息, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FromUserName: 自己的ID, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ToUserName: 好友的ID, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LocalID: 与clientMsgId相同, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClientMsgId: 时间戳左移4位随后补上4位随机数 &nbsp;&nbsp;&nbsp;&nbsp; } } 返回数据(JSON):1234567&#123; &quot;BaseResponse&quot;: &#123; &quot;Ret&quot;: 0, &quot;ErrMsg&quot;: &quot;&quot; &#125;, ...&#125; 更多资料：https://github.com/xiangzhai/qwxhttps://github.com/Urinx/WeixinBothttp://www.07net01.com/2016/01/1201188.htmlhttp://www.cnblogs.com/xiaozhi_5638/p/4923811.html","categories":[{"name":"其它","slug":"其它","permalink":"https://wangfeng.pro/categories/其它/"}],"tags":[{"name":"wechat","slug":"wechat","permalink":"https://wangfeng.pro/tags/wechat/"}]},{"title":"测试markdown语法","slug":"测试markdown语法","date":"2017-07-14T08:01:18.000Z","updated":"2018-01-12T12:08:31.383Z","comments":true,"path":"a/测试markdown语法/","link":"","permalink":"https://wangfeng.pro/a/测试markdown语法/","excerpt":"","text":"欢迎使用马克飞象@(Pro)[马克飞象, 帮助, Markdown] 马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述： 功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC] Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。或者块级公式： $$ x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： 已完成事项 待办事项1 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 印象笔记相关笔记本和标签马克飞象增加了@(笔记本)[标签A|标签B]语法, 以选择笔记本和添加标签。 绑定账号后， 输入(自动会出现笔记本列表，请从中选择。 笔记标题马克飞象会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 欢迎使用马克飞象。 快捷编辑保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到马克飞象中打开并编辑该笔记。 注意：目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。 数据同步马克飞象通过将Markdown原文以隐藏内容保存在笔记中的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。 隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。 离线存储马克飞象使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过文档管理打开。 注意：虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，请务必经常及时同步到印象笔记。 编辑器相关设置右侧系统菜单（快捷键Ctrl + M）的设置中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。 快捷键帮助 Ctrl + /同步文档 Ctrl + S创建文档 Ctrl + Alt + N最大化编辑器 Ctrl + Enter预览文档 Ctrl + Alt + Enter文档管理 Ctrl + O系统菜单 Ctrl + M 加粗 Ctrl + B插入图片 Ctrl + G插入链接 Ctrl + L提升标题 Ctrl + H 反馈与建议 微博：@马克飞象，@GGock 邮箱：&#104;&#117;&#x73;&#x74;&#103;&#x6f;&#99;&#107;&#x40;&#103;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109; 感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。","categories":[{"name":"其它","slug":"其它","permalink":"https://wangfeng.pro/categories/其它/"}],"tags":[{"name":"test","slug":"test","permalink":"https://wangfeng.pro/tags/test/"},{"name":"Markdown","slug":"Markdown","permalink":"https://wangfeng.pro/tags/Markdown/"}]},{"title":"单向链表基本操作","slug":"单向链表基本操作","date":"2017-06-07T02:29:58.000Z","updated":"2018-01-12T12:08:31.387Z","comments":true,"path":"a/单向链表基本操作/","link":"","permalink":"https://wangfeng.pro/a/单向链表基本操作/","excerpt":"","text":"单向链表节点123456789101112131415161718192021222324252627282930313233/** * 链表节点 */public static class Node&lt;E&gt; &#123; /** * 下一个节点 */ private Node&lt;E&gt; next; /** * 节点内容 */ private E data; public Node(E data) &#123; this.data = data; &#125; public Node&lt;E&gt; getNext() &#123; return next; &#125; public void setNext(Node&lt;E&gt; next) &#123; this.next = next; &#125; public E getData() &#123; return data; &#125; public void setData(E data) &#123; this.data = data; &#125;&#125; 链表结构12345678910111213141516public class SinglyLink&lt;E&gt; &#123; /** * 链表头 */ private Node&lt;E&gt; head = null; /** * 链表尾 */ private Node&lt;E&gt; last = null; /** * 链表的有效节点数量 */ private int size = 0;&#125; 相关操作向链表尾部插入数据1234567891011121314/** * 向链表尾部插入数据 */public void addLast(E data) &#123; Node&lt;E&gt; node = new Node&lt;&gt;(data); if (last == null) &#123; head = node; last = node; &#125; else &#123; last.next = node; last = node; &#125; size++;&#125; 向链表开头插入数据1234567891011121314/** * 向链表开头插入数据 */public void addFirst(E data) &#123; Node&lt;E&gt; node = new Node&lt;&gt;(data); if (head == null) &#123; last = node; head = node; &#125; else &#123; node.next = head; head = node; &#125; size++;&#125; 向链表的指定位置插入数据12345678910/** * 向链表的指定位置插入数据 */public void add(E data, int index) &#123; Node&lt;E&gt; node = new Node&lt;&gt;(data); Node&lt;E&gt; tmp = getNode(index); node.next = tmp.next; tmp.next = node; size++;&#125; 获取指定位置的节点数据123456789101112131415/** * 获取指定位置的节点数据 */public Node&lt;E&gt; getNode(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException(); &#125; int i = 0; Node&lt;E&gt; tmp = head; while (i &lt; index) &#123; tmp = tmp.next; i++; &#125; return tmp;&#125; 根据链表头节点，反转链表1234567891011121314151617/** * 根据链表头节点，反转链表 */public static &lt;E&gt; Node&lt;E&gt; reverse(Node&lt;E&gt; head) &#123; if (head == null || head.next == null) &#123; return head; &#125; Node&lt;E&gt; prev = null; Node&lt;E&gt; next = null; while (head != null) &#123; next = head.next; head.next = prev; prev = head; head = next; &#125; return prev;&#125; 判断链表是否有环路12345678910111213141516171819/** * 判断链表是否有环路 */public static &lt;E&gt; boolean hasCircle(Node&lt;E&gt; head) &#123; Node&lt;E&gt; fast = head; Node&lt;E&gt; slow = head; while (fast != null) &#123; fast = fast.next; slow = slow.next; if (fast == null) &#123; return false; &#125; fast = fast.next; if (fast != null &amp;&amp; fast == slow) &#123; return true; &#125; &#125; return false;&#125;","categories":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"https://wangfeng.pro/categories/算法与数据结构/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangfeng.pro/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://wangfeng.pro/tags/数据结构/"}]},{"title":"深入理解计算机系统学习笔记","slug":"深入理解计算机系统学习笔记","date":"2017-06-05T01:34:51.000Z","updated":"2018-01-12T12:08:31.387Z","comments":true,"path":"a/深入理解计算机系统学习笔记/","link":"","permalink":"https://wangfeng.pro/a/深入理解计算机系统学习笔记/","excerpt":"","text":"计算机系统中的抽象(P19) 文件是对I/O设备的抽象； 虚拟内存是对程序存储器的抽象； 进程是对一个正在运行的程序的抽象； 虚拟机是对整个计算机的抽象，包括操作系统、处理器和程序； 图例","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"https://wangfeng.pro/categories/计算机原理/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wangfeng.pro/tags/操作系统/"},{"name":"计算机","slug":"计算机","permalink":"https://wangfeng.pro/tags/计算机/"}]},{"title":"在SpringBoot里面使用thymeleaf3","slug":"在SpringBoot里面使用thymeleaf3","date":"2017-05-26T01:53:26.000Z","updated":"2018-01-12T12:08:31.387Z","comments":true,"path":"a/在SpringBoot里面使用thymeleaf3/","link":"","permalink":"https://wangfeng.pro/a/在SpringBoot里面使用thymeleaf3/","excerpt":"","text":"最近在一个springboot项目里使用thymeleaf模板，访问页面时一直报错。而之前的项目中没发现过这种情况发生。和之前的项目对比发现，在springboot项目中引入1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 引入的thymeleaf版本居然是2.x.x版本，之前项目引入的是3.x.x版本的 之前项目 该项目 查看相应的pom文件发现，thymeleaf.version确实是2.x.x的。 截图 究竟怎么回事呢？搜索springboot文档中相关thymeleaf的段落，发现了如下描述: 描述 原来在spring-boot-starter-thymeleaf中默认引入的版本thymeleaf是2.1,如果需要使用thymeleaf3,需要在pom.xml中加入如下配置：1234&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.2.RELEASE&lt;/thymeleaf.version&gt; &lt;thymeleaf-layout-dialect.version&gt;2.1.1&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wangfeng.pro/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://wangfeng.pro/tags/SpringBoot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"https://wangfeng.pro/tags/thymeleaf/"}]},{"title":"Runnable实现资源共享","slug":"Runnable实现资源共享","date":"2017-05-25T09:03:18.000Z","updated":"2018-01-12T12:08:31.386Z","comments":true,"path":"a/Runnable实现资源共享/","link":"","permalink":"https://wangfeng.pro/a/Runnable实现资源共享/","excerpt":"","text":"参考地址 以抢票或秒杀为例 错误示例1： Service 12345678910111213class Service implements Runnable &#123; private int remain = 100; public AtomicInteger count = new AtomicInteger(0); @Override public void run() &#123; while (remain &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + \" 剩余：\" + this.remain--); count.addAndGet(1); &#125; &#125;&#125; 测试方法： 12345678910111213141516171819202122232425public class Main &#123; public static int buy() throws InterruptedException &#123; Service service = new Service(); Thread[] threads = new Thread[100]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i] = new Thread(service); &#125; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i].start(); &#125; Thread.sleep(50); return service.count.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; int[] array = new int[100]; for (int i = 0; i &lt; array.length; i++) &#123; array[i] = buy(); &#125; long a = Arrays.stream(array).filter(i -&gt; i &gt; 100).count(); System.out.println(\"执行次数大于100的个数：\" + a); &#125;&#125; 测试结果： 截图 执行100次中出现了13次下单次数大于100次的情况 原因分析:在上述方法中，多个线程共享一个变量，会存在并发争抢资源的问题，可能多买票的现象。","categories":[{"name":"Java","slug":"Java","permalink":"https://wangfeng.pro/categories/Java/"}],"tags":[{"name":"thread","slug":"thread","permalink":"https://wangfeng.pro/tags/thread/"},{"name":"java","slug":"java","permalink":"https://wangfeng.pro/tags/java/"}]},{"title":"jquery checkbox选中、改变状态、change和click事件","slug":"jquery checkbox选中、改变状态、change和click事件","date":"2017-05-25T02:55:13.000Z","updated":"2018-01-12T12:08:31.386Z","comments":true,"path":"a/jquery checkbox选中、改变状态、change和click事件/","link":"","permalink":"https://wangfeng.pro/a/jquery checkbox选中、改变状态、change和click事件/","excerpt":"","text":"原文 jquery判断checked的三种方法: 123.attr('checked'); //看版本1.6+返回:”checked”或”undefined” ;1.5-返回:true或false.prop('checked'); //1.6+:true/false.is(':checked'); //所有版本:true/false//别忘记冒号哦 jquery赋值checked的几种写法: 123456789101112//所有的jquery版本都可以这样赋值:$(\"#cb1\").attr(\"checked\", \"checked\");$(\"#cb1\").attr(\"checked\", true);//jquery1.6+:prop的4种赋值:$(\"#cb1\").prop(\"checked\", true);$(\"#cb1\").prop(&#123;checked: true&#125;);$(\"#cb1\").prop(\"checked\", function () &#123; return true;//函数返回true或false&#125;);//记得还有这种哦:$(\"#cb1″).prop(\"checked\",\"checked\"); checkbox click和change事件 123456789101112131415161718192021222324252627282930313233343536//方法1:$(\"#ischange\").change(function () &#123; alert(\"checked\");&#125;);//方法2:$(function () &#123; if ($.browser.msie) &#123; $('input:checkbox').click(function () &#123; this.blur(); this.focus(); &#125;); &#125;&#125;);//方法3：$(\"#ischange\").change(function () &#123; alert(\"checked\");&#125;);//方法4:$(function () &#123; if ($.browser.msie) &#123; $('input:checkbox').click(function () &#123; this.blur(); this.focus(); &#125;); &#125;&#125;);//方法5:$(document).ready(function () &#123; $(\"testCheckbox\").change(function () &#123; alert(\"Option changed!\"); &#125;);&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://wangfeng.pro/categories/前端/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wangfeng.pro/tags/jquery/"}]},{"title":"nginx出现413 Request Entity Too Large 解决方法","slug":"nginx出现413 Request Entity Too Large 解决方法","date":"2017-05-24T07:50:14.000Z","updated":"2018-01-12T12:08:31.385Z","comments":true,"path":"a/nginx出现413 Request Entity Too Large 解决方法/","link":"","permalink":"https://wangfeng.pro/a/nginx出现413 Request Entity Too Large 解决方法/","excerpt":"","text":"nginx.conf中默认没有设置client_max_body_size，这个参数默认只是1M，解决办法：增加如下两行到nginx.conf的http{}段， 增大nginx上传文件大小限制123#设置允许发布内容为8Mclient_max_body_size 8M;client_body_buffer_size 128k;","categories":[{"name":"其它","slug":"其它","permalink":"https://wangfeng.pro/categories/其它/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://wangfeng.pro/tags/nginx/"}]},{"title":"水仙花算法","slug":"水仙花算法","date":"2017-05-23T03:24:15.000Z","updated":"2018-01-12T12:08:31.385Z","comments":true,"path":"a/水仙花算法/","link":"","permalink":"https://wangfeng.pro/a/水仙花算法/","excerpt":"","text":"算法描述 水仙花数是一个n(&gt;=3)位数字的数,它等于每个数字的n次幂之和 列如153分别是1 5 3 这几个数的立方之和 算法实现12345678910111213141516171819202122232425262728293031323334353637/** * 计算从100到endNum范围内的水仙花数 */public int[] narcissisticNumber(int endNum) &#123; return IntStream.range(100, endNum).parallel() //判断n是否为水仙花数 .filter(n -&gt; isNarcissistic(n)) //得到结 果作为数值返回 .toArray();&#125;/** * 判断一个整数是否是水仙花数 */private boolean isNarcissistic(int n) &#123; //切割整数 String[] array = String.valueOf(n).split(\"\"); int sum = Arrays.stream(array) //n次方 .mapToInt(i -&gt; nPower(Integer.valueOf(i), array.length)) //求和 .sum(); return sum == n;&#125;/** * 计算n次方 */public int nPower(int i, int n) &#123; int sum = 1; while (n &gt; 0) &#123; sum *= i; n--; &#125; return sum;&#125; 测试12345678/** * 计算1_0000_0000以内的水仙花数 */@Testpublic void test() &#123; int[] ints = narcissisticNumber(1_0000_0000); Arrays.stream(ints).forEach(System.out::println);&#125; 输出1234567891011121314151617181533703714071634820894745474892727930845488341741725421081898008179926315246780502467805188593477","categories":[{"name":"Java","slug":"Java","permalink":"https://wangfeng.pro/categories/Java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"https://wangfeng.pro/tags/java8/"},{"name":"算法","slug":"算法","permalink":"https://wangfeng.pro/tags/算法/"}]},{"title":"java8中利用Stream过滤属性重复的元素","slug":"java8中利用Stream过滤属性重复的元素","date":"2017-05-23T03:10:08.000Z","updated":"2018-01-12T12:08:31.384Z","comments":true,"path":"a/java8中利用Stream过滤属性重复的元素/","link":"","permalink":"https://wangfeng.pro/a/java8中利用Stream过滤属性重复的元素/","excerpt":"","text":"根据属性过滤重复的元素参考地址1234567/** * 根据属性过滤重复的元素 */public static &lt;T&gt; Predicate&lt;T&gt; distinctByKey(Function&lt;? super T,Object&gt; keyExtractor) &#123; Map&lt;Object,Boolean&gt; seen = new ConcurrentHashMap&lt;&gt;(); return t -&gt; seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637static String[] data = new String[]&#123; \"1,2,a,4,5,6\", \"2,2,b,4,5,6\", \"3,2,a,4,5,6\", \"4,2,d,4,5,6\", \"5,2,b,5,5,6\", \"6,2,f,4,5,6\", \"7,2,c,4,5,6\", \"8,2,g,4,5,6\", \"9,2,d,4,5,6\", \"10,2,g,5,5,6\",&#125;;/** * 根据单个属性过滤 */@Testpublic void test1() &#123; int[] arrays = Stream.of(data).map(d -&gt; d.split(\",\")) .filter(array -&gt; !array[0].equals(\"1\")) .filter(distinctByKey(array -&gt; array[2])) .mapToInt(array -&gt; Integer.valueOf(array[0])) .toArray(); Assert.assertArrayEquals(new int[]&#123;2, 3, 4, 6, 7, 8&#125;, arrays);&#125;/** * 根据多个属性过滤 */@Testpublic void test2() &#123; int[] arrays = Stream.of(data).map(d -&gt; d.split(\",\")) .filter(distinctByKey(array -&gt; array[2] + array[3])) .mapToInt(array -&gt; Integer.valueOf(array[0])) .toArray(); Assert.assertArrayEquals(new int[]&#123;1, 2, 4, 5, 6, 7, 8, 10&#125;, arrays);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://wangfeng.pro/categories/Java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"https://wangfeng.pro/tags/java8/"},{"name":"stream","slug":"stream","permalink":"https://wangfeng.pro/tags/stream/"}]}]}