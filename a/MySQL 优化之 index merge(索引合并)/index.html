<!DOCTYPE html>
<html>
<head>
    

    
<!-- Tencent Speed -->
<script>var _speedMark = new Date()</script>
<!-- End Tencent Speed -->
<!-- Tencent Analysis -->
<script async src="//tajs.qq.com/stats?sId=64984551"></script>
<!-- End Tencent Analysis -->


    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?db673367eaa18d14a5ec59d6cb0ee5e7"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    
    <title>MySQL 优化之 index merge(索引合并) | 王峰的个人博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="MySQL,索引">
    <meta name="description" content="深入理解 index merge 是使用索引进行优化的重要基础之一。理解了 index merge 技术，我们才知道应该如何在表上建立索引。  1. 为什么会有index merge我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个">
<meta name="keywords" content="MySQL,索引">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 优化之 index merge(索引合并)">
<meta property="og:url" content="https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/index.html">
<meta property="og:site_name" content="王峰的个人博客">
<meta property="og:description" content="深入理解 index merge 是使用索引进行优化的重要基础之一。理解了 index merge 技术，我们才知道应该如何在表上建立索引。  1. 为什么会有index merge我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-01-12T12:08:31.388Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL 优化之 index merge(索引合并)">
<meta name="twitter:description" content="深入理解 index merge 是使用索引进行优化的重要基础之一。理解了 index merge 技术，我们才知道应该如何在表上建立索引。  1. 为什么会有index merge我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个">
    
        <link rel="alternate" type="application/atom+xml" title="王峰的个人博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="https://file.wf2311.com/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="https://file.wf2311.com/wf2311.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">王峰</h5>
          <a href="mailto:wf2311@163.com" title="wf2311@163.com" class="mail">wf2311@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/wf2311" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                GitHub
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://gitee.com/wf2311" target="_blank" >
                <i class="icon icon-lg icon-git-square"></i>
                码云
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://segmentfault.com/u/wf2311" target="_blank" >
                <i class="icon icon-lg icon-stack-exchange"></i>
                SegmentFault
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/wf2311" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                微博
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">MySQL 优化之 index merge(索引合并)</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">MySQL 优化之 index merge(索引合并)</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-07-14T08:09:10.000Z" itemprop="datePublished" class="page-time">
  2017-07-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/数据库/">数据库</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-为什么会有index-merge"><span class="post-toc-number">1.</span> <span class="post-toc-text">1. 为什么会有index merge</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-index-merge-之-intersect"><span class="post-toc-number">2.</span> <span class="post-toc-text">2. index merge 之 intersect</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-index-merge-之-union"><span class="post-toc-number">3.</span> <span class="post-toc-text">3. index merge 之 union</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-index-merge-之-sort-union"><span class="post-toc-number">4.</span> <span class="post-toc-text">4. index merge 之 sort_union</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-index-merge的局限"><span class="post-toc-number">5.</span> <span class="post-toc-text">5. index merge的局限</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#6-对-index-merge-的进一步优化"><span class="post-toc-number">6.</span> <span class="post-toc-text">6. 对 index merge 的进一步优化</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#7-复合索引的最左前缀原则"><span class="post-toc-number">7.</span> <span class="post-toc-text">7. 复合索引的最左前缀原则</span></a></li></ol>
        </nav>
    </aside>
    
<article data-id="34863542213677056" id="post-MySQL 优化之 index merge(索引合并)"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">MySQL 优化之 index merge(索引合并)</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-07-14 16:09:10" datetime="2017-07-14T08:09:10.000Z"  itemprop="datePublished">2017-07-14 16:09:10</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/数据库/">数据库</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>深入理解 index merge 是使用索引进行优化的重要基础之一。理解了 index merge 技术，我们才知道应该如何在表上建立索引。</p>
</blockquote>
<h1 id="1-为什么会有index-merge"><a href="#1-为什么会有index-merge" class="headerlink" title="1. 为什么会有index merge"></a>1. 为什么会有index merge</h1><p>我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。</p>
<p>MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描。</p>
<p>相关文档：<a href="http://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.6/en/index-merge-optimization.html</a> (注意该文档中说的有几处错误)</p>
<p>The Index Merge method is used to retrieve rows with several range scans and to merge their results into one. The merge can produce unions, intersections, or unions-of-intersections of its underlying scans. This access method merges index scans from a single table; it does not merge scans across multiple tables.</p>
<p>In EXPLAIN output, the Index Merge method appears as index_merge in the type column. In this case, the key column contains a list of indexes used, and key_len contains a list of the longest key parts for those indexes.</p>
<p>index merge: 同一个表的多个索引的范围扫描可以对结果进行合并，合并方式分为三种：union, intersection, 以及它们的组合(先内部intersect然后在外面union)。</p>
<p>官方文档给出了四个例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key1 = <span class="number">10</span> <span class="keyword">OR</span> key2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> (key1 = <span class="number">10</span> <span class="keyword">OR</span> key2 = <span class="number">20</span>) <span class="keyword">AND</span> non_key=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> (t1.key1 <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">OR</span> t1.key2 <span class="keyword">LIKE</span> <span class="string">'value%'</span>) <span class="keyword">AND</span> t2.key1=t1.some_col;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.key1=<span class="number">1</span> <span class="keyword">AND</span> (t2.key1=t1.some_col <span class="keyword">OR</span> t2.key2=t1.some_col2);</span><br></pre></td></tr></table></figure></p>
<p>但是第四个例子，感觉并不会使用 index merge. 因为 t2.key1=t1.some_col 和 t2.key2=t1.some_col2 之间进行的是 OR 运算，而且 t2.key2 是复合索引的第二个字段(非第一个字段)。所以：t2.key2 = t1.some_col2 并不能使用到复合索引。(文档这里应该是错误的)</p>
<p>index merge 算法根据合并算法的不同分成了三种：intersect, union, sort_union. </p>
<h1 id="2-index-merge-之-intersect"><a href="#2-index-merge-之-intersect" class="headerlink" title="2. index merge 之 intersect"></a>2. index merge 之 intersect</h1><p>简单而言，index intersect merge就是多个索引条件扫描得到的结果进行交集运算。显然在多个索引提交之间是 AND 运算时，才会出现 index intersect merge. 下面两种where条件或者它们的组合时会进行 index intersect merge:</p>
<p>1) 条件使用到复合索引中的所有字段或者左前缀字段(对单字段索引也适用)</p>
<p>key_part1=const1 AND key_part2=const2 … AND key_partN=constN<br>2) 主键上的任何范围条件</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> innodb_table <span class="keyword">WHERE</span> primary_key &lt; <span class="number">10</span> <span class="keyword">AND</span> key_col1=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> (key1_part1=<span class="number">1</span> <span class="keyword">AND</span> key1_part2=<span class="number">2</span>) <span class="keyword">AND</span> key2=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面只说到复合索引，但是其实单字段索引显然也是一样的。比如 select * from tab where key1=xx and key2 =xxx; 也是有可能进行index intersect merge的。另外上面两种情况的 AND 组合也一样可能会进行 index intersect merge.</p>
<p>The Index Merge intersection algorithm performs simultaneous scans on all used indexes and produces the intersection of row sequences that it receives from the merged index scans. (intersect merge运行方式：多个索引同时扫描，然后结果取交集)</p>
<p>If all columns used in the query are covered by the used indexes, full table rows are not retrieved (EXPLAIN output contains Using index in Extra field in this case). Here is an example of such a query:(索引覆盖扫描，无需回表)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> key1=<span class="number">1</span> <span class="keyword">AND</span> key2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>If the used indexes do not cover all columns used in the query, full rows are retrieved only when the range conditions for all used keys are satisfied.(索引不能覆盖，则对满足条件的再进行回表)</p>
<p>If one of the merged conditions is a condition over a primary key of an InnoDB table, it is not used for row retrieval, but is used to filter out rows retrieved using other conditions.</p>
<h1 id="3-index-merge-之-union"><a href="#3-index-merge-之-union" class="headerlink" title="3. index merge 之 union"></a>3. index merge 之 union</h1><p>简单而言，index uion merge就是多个索引条件扫描，对得到的结果进行并集运算，显然是多个条件之间进行的是 OR 运算。</p>
<p>下面几种类型的 where 条件，以及他们的组合可能会使用到 index union merge算法：</p>
<p>1) 条件使用到复合索引中的所有字段或者左前缀字段(对单字段索引也适用)</p>
<p>2) 主键上的任何范围条件</p>
<p>3) 任何符合 index intersect merge 的where条件；</p>
<p>上面三种 where 条件进行 OR 运算时，可能会使用 index union merge算法。</p>
<p>例子：</p>
<p>SELECT <em> FROM t1 WHERE key1=1 OR key2=2 OR key3=3;<br>SELECT </em> FROM innodb_table WHERE (key1=1 AND key2=2) OR (key3=’foo’ AND key4=’bar’) AND key5=5;<br>第一个例子，就是三个 单字段索引 进行 OR 运算，所以他们可能会使用 index union merge算法。</p>
<p>第二个例子，复杂一点。(key1=1 AND key2=2) 是符合 index intersect merge; (key3=’foo’ AND key4=’bar’) AND key5=5 也是符合index intersect merge，所以 二者之间进行 OR 运算，自然可能会使用 index union merge算法。</p>
<h1 id="4-index-merge-之-sort-union"><a href="#4-index-merge-之-sort-union" class="headerlink" title="4. index merge 之 sort_union"></a>4. index merge 之 sort_union</h1><p>This access algorithm is employed when the WHERE clause was converted to several range conditions combined by OR, but for which the Index Merge method union algorithm is not applicable.(多个条件扫描进行 OR 运算，但是不符合 index union merge算法的，此时可能会使用 sort_union算法)</p>
<p>官方文档给出了两个例子：</p>
<p>SELECT <em> FROM tbl_name WHERE key_col1 &lt; 10 OR key_col2 &lt; 20;<br>SELECT </em> FROM tbl_name WHERE (key_col1 &gt; 10 OR key_col2 = 20) AND nonkey_col=30;<br>但是显然：因为 key_col2 不是复合索引的第一个字段，对它进行 OR 运算，是不可能使用到索引的。所以这两个例子应该也是错误的，它们实际上并不会进行 index sort_union merge算法。</p>
<p>The difference between the sort-union algorithm and the union algorithm is that the sort-union algorithm must first fetch row IDs for all rows and sort them before returning any rows.(sort-union合并算法和union合并算法的不同点，在于返回结果之前是否排序，为什么需要排序呢？可能是因为两个结果集，进行并集运算，需要去重，所以才进行排序？？？)</p>
<h1 id="5-index-merge的局限"><a href="#5-index-merge的局限" class="headerlink" title="5. index merge的局限"></a>5. index merge的局限</h1><p>1）If your query has a complex WHERE clause with deep AND/OR nesting and MySQL does not choose the optimal plan, try distributing terms using the following identity laws:</p>
<p>(x AND y) OR z = (x OR z) AND (y OR z)<br>(x OR y) AND z = (x AND z) OR (y AND z)<br>如果我们的条件比较复杂，用到多个 and / or 条件运算，而MySQL没有使用最优的执行计划，那么可以使用上面的两个等式将条件进行转换一下。</p>
<p>2）Index Merge is not applicable to full-text indexes. We plan to extend it to cover these in a future MySQL release.(全文索引没有index merge)</p>
<p>3）Before MySQL 5.6.6, if a range scan is possible on some key, the optimizer will not consider using Index Merge Union or Index Merge Sort-Union algorithms. For example, consider this query:</p>
<p>SELECT * FROM t1 WHERE (goodkey1 &lt; 10 OR goodkey2 &lt; 20) AND badkey &lt; 30;<br>For this query, two plans are possible:</p>
<p>An Index Merge scan using the (goodkey1 &lt; 10 OR goodkey2 &lt; 20) condition.</p>
<p>A range scan using the badkey &lt; 30 condition.</p>
<p>However, the optimizer considers only the second plan.</p>
<p>这一点对以低版本的MySQL是一个很大的缺陷。就是如果where条件中有 &gt;, &lt;, &gt;=, &lt;=等条件，那么优化器不会使用 index merge，而且还会忽略其他的索引，不会使用它们，哪怕他们的选择性更优。</p>
<h1 id="6-对-index-merge-的进一步优化"><a href="#6-对-index-merge-的进一步优化" class="headerlink" title="6. 对 index merge 的进一步优化"></a>6. 对 index merge 的进一步优化</h1><p>index merge使得我们可以使用到多个索引同时进行扫描，然后将结果进行合并。听起来好像是很好的功能，但是如果出现了 index intersect merge，那么一般同时也意味着我们的索引建立得不太合理，因为 index intersect merge 是可以通过建立 复合索引进行更一步优化的。</p>
<p>比如下面的select:</p>
<p>SELECT * FROM t1 WHERE key1=1 AND key2=2 AND key3=3;<br>显然我们是可以在这三个字段上建立一个复合索引来进行优化的，这样就只需要扫描一个索引一次，而不是对三个所以分别扫描一次。</p>
<p>percona官网有一篇 比较复合索引和index merge 的好文章：Multi Column indexes vs Index Merge</p>
<h1 id="7-复合索引的最左前缀原则"><a href="#7-复合索引的最左前缀原则" class="headerlink" title="7. 复合索引的最左前缀原则"></a>7. 复合索引的最左前缀原则</h1><p>上面我们说到，对复合索引的非最左前缀字段进行 OR 运算，是无法使用到复合索引的。比如：</p>
<p>SELECT * FROM tbl_name WHERE (key_col1 &gt; 10 OR key_col2 = 20) AND nonkey_col=30;<br>其原因是，MySQL中的索引，使用的是B+tree, 也就是说他是：先按照复合索引的 第一个字段的大小来排序，插入到 B+tree 中的，当第一个字段值相同时，在按照第二个字段的值比较来插入的。那么如果我们需要对： OR key_col2 = 20 这样的条件也使用复合索引，那么该怎么操作呢？应该要对复合索引进行全扫描，找出所有 key_col2 =20 的项，然后还要回表去判断 nonkey_col=30，显然代价太大了。所以一般而言 OR key_col2 = 20 这样的条件是无法使用到复合索引的。如果一定要使用索引，那么可以在 col2 上单独建立一个索引。</p>
<p>复合索引的最左前缀原则：</p>
<p>MySQL中的复合索引，查询时只会使用到最左前缀，比如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    mysql&gt; show index from role_goods;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">    | Table      | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">    +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">    | role_goods |          0 | PRIMARY  |            1 | id          | A         |       22816 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">    | role_goods |          1 | roleId   |            1 | roleId      | A         |        1521 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">    | role_goods |          1 | goodsId  |            1 | goodsId     | A         |        1521 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">    | role_goods |          1 | roleId_2 |            1 | roleId      | A         |        1901 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">    | role_goods |          1 | roleId_2 |            2 | status      | A         |        4563 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">    | role_goods |          1 | roleId_2 |            3 | number      | A         |       22816 |     NULL | NULL   | YES  | BTREE      |         |               |</span><br><span class="line">    +------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>上面有一个复合索引：roleId_2(roleId,status,number)，如果条件是： where roleId=xxx and number=xxx，那么此时只会使用到最左前缀roleId，而不会使用到 number 来进行过滤。因为它们中间存在一个字段 status 没有出现在where条件中。实验如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span> explain select * from role_goods where roleId=100000001 and status=1 and number=1 limit 1;</span><br><span class="line">+----+-------------+------------+------+-----------------+----------+---------+-------------------+------+-------+</span><br><span class="line">| id | select_type | table      | type | possible_keys   | key      | key_len | ref               | rows | Extra |</span><br><span class="line">+----+-------------+------------+------+-----------------+----------+---------+-------------------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | role_goods | ref  | roleId,roleId_2 | roleId_2 | 23      | const,const,const |   13 | NULL  |</span><br><span class="line">+----+-------------+------------+------+-----------------+----------+---------+-------------------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> explain select * from role_goods where roleId=100000001 and status=1 limit 1;</span><br><span class="line">+----+-------------+------------+------+-----------------+----------+---------+-------------+------+-------+</span><br><span class="line">| id | select_type | table      | type | possible_keys   | key      | key_len | ref         | rows | Extra |</span><br><span class="line">+----+-------------+------------+------+-----------------+----------+---------+-------------+------+-------+</span><br><span class="line">|  1 | SIMPLE      | role_goods | ref  | roleId,roleId_2 | roleId_2 | 14      | const,const |   13 | NULL  |</span><br><span class="line">+----+-------------+------------+------+-----------------+----------+---------+-------------+------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span> explain select * from role_goods where roleId=100000001 and number=1 limit 1;</span><br><span class="line">+----+-------------+------------+------+-----------------+--------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table      | type | possible_keys   | key    | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+------------+------+-----------------+--------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | role_goods | ref  | roleId,roleId_2 | roleId | 9       | const |   14 | Using where |</span><br><span class="line">+----+-------------+------------+------+-----------------+--------+---------+-------+------+-------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"><span class="meta">mysql&gt;</span> explain select * from role_goods ignore index(roleId) where roleId=100000001 and number=1 limit 1;</span><br><span class="line">+----+-------------+------------+------+---------------+----------+---------+-------+------+-----------------------+</span><br><span class="line">| id | select_type | table      | type | possible_keys | key      | key_len | ref   | rows | Extra                 |</span><br><span class="line">+----+-------------+------------+------+---------------+----------+---------+-------+------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | role_goods | ref  | roleId_2      | roleId_2 | 9       | const |   14 | Using index condition |</span><br><span class="line">+----+-------------+------------+------+---------------+----------+---------+-------+------+-----------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>key_len</code> 的变化：</p>
<p>显然最后一个查询仅仅使用到符合索引中的 roleId, 没有使用到 number. number使用在了 index conditon(也就是索引的push down技术)</p>
<p>注意最左前缀，并不是是指：一定要按照各个字段出现在where中的顺序来建立复合索引的。比如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where status=2 and roleId=xxx and number = xxx</span><br></pre></td></tr></table></figure></p>
<p>该条件建立符合索引，我们并不需要按照status,roleId，number它们出现的顺序来建立索引：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> role_goods <span class="keyword">add</span> <span class="keyword">index</span> <span class="keyword">sin</span>(<span class="keyword">status</span>,roleId,<span class="built_in">number</span>)</span><br></pre></td></tr></table></figure></p>
<p>这是对最左前缀极大的误解。因为 <code>where status=2 and roleId=xxx and number = xxx 和 where roleId=xxx and number = xxx and status=2</code>它们是等价的。复合索引，哪个字段放在最前面，需要根据哪个字段经常出现在where条件中，哪个字段的选择性最好来判断的。</p>
<p>进一步可以参考的文章：</p>
<p><a href="http://www.orczhou.com/index.php/2013/01/mysql-source-code-query-optimization-index-merge/" title="http://www.orczhou.com/index.php/2013/01/mysql-source-code-query-optimization-index-merge/" target="_blank" rel="noopener">http://www.orczhou.com/index.php/2013/01/mysql-source-code-query-optimization-index-merge/</a></p>
<p><a href="http://www.cnblogs.com/nocode/archive/2013/01/28/2880654.html" title="http://www.cnblogs.com/nocode/archive/2013/01/28/2880654.html" target="_blank" rel="noopener">http://www.cnblogs.com/nocode/archive/2013/01/28/2880654.html</a></p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-01-12T12:08:31.388Z" itemprop="dateUpdated">2018-01-12 20:08:31</time>
</span><br>


        
    </div>
    <footer>
        <a href="https://wangfeng.pro">
            <img src="https://file.wf2311.com/wf2311.png" alt="王峰">
            王峰
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/索引/">索引</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/&title=《MySQL 优化之 index merge(索引合并)》 — 王峰的个人博客&pic=https://file.wf2311.com/wf2311.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/&title=《MySQL 优化之 index merge(索引合并)》 — 王峰的个人博客&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《MySQL 优化之 index merge(索引合并)》 — 王峰的个人博客&url=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/&via=https://wangfeng.pro" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/a/使用thymeleaf变量给onclick属性赋值/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">使用thymeleaf变量给onclick属性赋值</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/a/微信web协议分析和实现微信机器人/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">微信web协议分析和实现微信机器人</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">

    <div id="SOHUCS" sid="34863542213677056"></div>
    <script type="text/javascript">
        (function () {
            var appid = 'cyteanoMa';
            var conf = 'prod_27ac74f72c70e7240b5f924ef92bae6a';
            var width = window.innerWidth || document.documentElement.clientWidth;
            if (width < 960) {
                window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
            } else {
                var loadJs = function (d, a) {
                    var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement;
                    var b = document.createElement("script");
                    b.setAttribute("type", "text/javascript");
                    b.setAttribute("charset", "UTF-8");
                    b.setAttribute("src", d);
                    if (typeof a === "function") {
                        if (window.attachEvent) {
                            b.onreadystatechange = function () {
                                var e = b.readyState;
                                if (e === "loaded" || e === "complete") {
                                    b.onreadystatechange = null;
                                    a()
                                }
                            }
                        } else {
                            b.onload = a
                        }
                    }
                    c.appendChild(b)
                };
                loadJs("https://changyan.sohu.com/upload/changyan.js", function () {
                    window.changyan.api.config({appid: appid, conf: conf})
                });
            }
        })(); </script>
</section>
















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="https://file.wf2311.com/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="https://file.wf2311.com/wechat.png" data-alipay="https://file.wf2311.com/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>王峰 &copy; 2017 - 2018</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">鄂ICP备15002386号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/&title=《MySQL 优化之 index merge(索引合并)》 — 王峰的个人博客&pic=https://file.wf2311.com/wf2311.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/&title=《MySQL 优化之 index merge(索引合并)》 — 王峰的个人博客&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《MySQL 优化之 index merge(索引合并)》 — 王峰的个人博客&url=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/&via=https://wangfeng.pro" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://wangfeng.pro/a/MySQL 优化之 index merge(索引合并)/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACu0lEQVR42u3awW4bMQwE0Pz/T7fXFmnkGXKVuMDzKYe1rKcAK2LIj4/48+v4+fOZz89/Xif/+7zaYx88PDy8a1s/bzdZ/3wQ7XGc94yHh4d3m/fVtpIX9xnWPtnu58Uv4uHh4b0Nb/ZCz4vm87WEh4eH9z/ykqK8LX/bsAMPDw/vZ3n50vmrvD2+PAq5krXg4eHhxbxNWPBTf1/p7+Hh4eGtu+ptiZy/9G9cBv9YBw8PD+8Cb9b+bzHty31TLuPh4eG9A+/edvNr4zz49aL4xsPDw3uUt9n6+Wf2281/pW594eHh4V3g5Q3+PJ7IX+7tCi9iCDw8PLxHeeexgHZQoA1hZ+23Ve8ODw8Pb81rc4vk+dmG2oA4Cnzx8PDwLvDypdvSuR2lmrW7omIdDw8P7xrvqbZ9G7/OVigiDDw8PLwLvDZgbXOAJMhoX/15LIKHh4d3gzdr3m/GBfbHkbTo8PDw8O7xkq/ttz4LI/Ihhhf/Bjw8PLyHeMlCm1GqTRQ7u5CKmTI8PDy8Ba9tbs0K5dmnPbgvJyPw8PDwHuIlm07C0zxcaKOE2X7w8PDw7vHaL5/jgHNrvz3KWZRcnzEeHh7eiLePUPfR8H4MCw8PD+97eLNxgaROnwWy+XWSF/d4eHh4N3hJHLA6rbjZtin0ozYYHh4e3gVe2/RqL4bN+nm08UBVjoeHhxfw2tChvTzygLiNjPHw8PB+lpeXtu24QHIom8GsYiYCDw8Pb8GbNcA2Da02CJ5dYH8NXeHh4eE9ypuFsO3oQNsqyy+VTayMh4eHt+Ftlm5D2/w42rJ+OFmGh4eHt+DtX+s5Pm+J7UfE8PDw8N6Blz/TXgyzvT18MeDh4eFdqznzoai8VdYmCdFh4eHh4V3jtU2vdpC0HaJ66rjx8PDwbvDa0raNd/N2Wo5/oKeHh4eHN+H9BnObxTqmZFiFAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
